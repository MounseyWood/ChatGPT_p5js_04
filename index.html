<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Cloth – Full Construction & Cylinder Collision</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
  <style>
    body, html {
      margin: 0; padding: 0;
      background: #111; color: #fff;
      font-family: sans-serif;
      height: 100%;
    }
    #uiPanel {
      position: absolute; top: 0; left: 0;
      width: 280px; height: 100%;
      background: #222; padding: 20px;
      box-sizing: border-box; overflow-y: auto;
      box-shadow: 2px 0 8px rgba(0,0,0,0.5);
    }
    #canvasContainer {
      position: absolute; top: 0; left: 280px;
      width: calc(100% - 280px); height: 100%;
      overflow: hidden;
    }
    h2 { margin-top: 0; }
    p, label { font-size: 14px; line-height: 1.4em; margin-bottom: 8px; }
    .parameter {
      margin-bottom: 12px; padding-bottom: 8px;
      border-bottom: 1px solid #333;
    }
    .paramHeader { margin-bottom: 4px; font-weight: bold; }
    .paramRadio { display: flex; gap: 8px; margin-bottom: 4px; }
    .paramRadio input[type="radio"] { accent-color: #1e90ff; }
    input[type="range"] { accent-color: #1e90ff; }
    .paramContainer { display: none; margin-top: 4px; }
    .paramDesc { font-size: 12px; color: #aaa; margin-top: 4px; }
    .bottomButtons {
      position: sticky; bottom: 20px; width: 100%;
    }
    button {
      width: 100%; padding: 8px 12px; background: #555; color: #fff;
      border: none; cursor: pointer; margin-bottom: 10px;
    }
    button:hover { background: #666; }
  </style>
</head>
<body>
<div id="uiPanel">
  <h2>3D Cloth Simulation</h2>
  <p>
    A fully subdivided cloth. Toggle <strong>Stretch, Shear, Bending</strong> ON to see the dense mesh.<br>
    Cylinder top=150, bottom=450. Cloth pinned at y=150, falls “down” to y=450.
  </p>

  <!-- Simulation Mode -->
  <div class="parameter">
    <div class="paramHeader">Simulation Mode:</div>
    <div id="simModeRadio"></div>
    <div class="paramDesc">"Plane" or "Draped".</div>
  </div>

  <!-- Form Mode -->
  <div class="parameter">
    <div class="paramHeader">Form Mode:</div>
    <div id="formModeRadio"></div>
    <div class="paramDesc">"Sphere" or "Cylinder".</div>
  </div>

  <!-- Interaction Mode -->
  <div class="parameter">
    <div class="paramHeader">Interaction Mode:</div>
    <div id="interactionRadioGroup"></div>
    <div class="paramDesc">"Rotate" or "Drag".</div>
  </div>

  <!-- Pinning Mode (Plane only) -->
  <div class="parameter">
    <div class="paramHeader">Pinning Mode:</div>
    <div id="pinningRadio"></div>
    <div class="paramDesc">For Plane mode only.</div>
  </div>

  <!-- Damping -->
  <div class="parameter">
    <div class="paramHeader">Damping: <span id="dampingVal"></span></div>
    <div class="paramRadio" id="dampingRadioGroup"></div>
    <div id="dampingContainer" class="paramContainer">
      <div id="dampingSlider"></div>
      <div class="paramDesc">Controls energy loss (Off=1.0).</div>
    </div>
  </div>

  <!-- Iterations -->
  <div class="parameter">
    <div class="paramHeader">Iterations: <span id="iterationsVal"></span></div>
    <div class="paramRadio" id="iterationsRadioGroup"></div>
    <div id="iterationsContainer" class="paramContainer">
      <div id="iterationsSlider"></div>
      <div class="paramDesc">Constraint relaxations/frame (Off=1).</div>
    </div>
  </div>

  <!-- Stretch, Shear, Bending -->
  <div class="parameter">
    <div class="paramHeader">Stretch: <span id="stretchVal"></span></div>
    <div class="paramRadio" id="stretchRadioGroup"></div>
    <div id="stretchContainer" class="paramContainer">
      <div id="stretchSlider"></div>
      <div class="paramDesc">Affects cloth extension (Off=1.0).</div>
    </div>
  </div>
  <div class="parameter">
    <div class="paramHeader">Shear: <span id="shearVal"></span></div>
    <div class="paramRadio" id="shearRadioGroup"></div>
    <div id="shearContainer" class="paramContainer">
      <div id="shearSlider"></div>
      <div class="paramDesc">Resists diagonal distortion (Off=1.0).</div>
    </div>
  </div>
  <div class="parameter">
    <div class="paramHeader">Bending: <span id="bendingVal"></span></div>
    <div class="paramRadio" id="bendingRadioGroup"></div>
    <div id="bendingContainer" class="paramContainer">
      <div id="bendingSlider"></div>
      <div class="paramDesc">Resistance to sharp folds (Off=1.0).</div>
    </div>
  </div>

  <!-- Weight -->
  <div class="parameter">
    <div class="paramHeader">Weight: <span id="weightVal"></span></div>
    <div class="paramRadio" id="weightRadioGroup"></div>
    <div id="weightContainer" class="paramContainer">
      <div id="weightSlider"></div>
      <div class="paramDesc">Downward pull (Off=1.0).</div>
    </div>
  </div>

  <!-- Wind X/Y/Z & Buffer -->
  <div class="parameter">
    <div class="paramHeader">Wind X: <span id="windXVal"></span></div>
    <div class="paramRadio" id="windXRadioGroup"></div>
    <div id="windXContainer" class="paramContainer">
      <div id="windXSlider"></div>
      <div class="paramDesc">Wind force along X (Off=0).</div>
    </div>
  </div>
  <div class="parameter">
    <div class="paramHeader">Wind Y: <span id="windYVal"></span></div>
    <div class="paramRadio" id="windYRadioGroup"></div>
    <div id="windYContainer" class="paramContainer">
      <div id="windYSlider"></div>
      <div class="paramDesc">Wind force along Y (Off=0).</div>
    </div>
  </div>
  <div class="parameter">
    <div class="paramHeader">Wind Z: <span id="windZVal"></span></div>
    <div class="paramRadio" id="windZRadioGroup"></div>
    <div id="windZContainer" class="paramContainer">
      <div id="windZSlider"></div>
      <div class="paramDesc">Wind force along Z (Off=0).</div>
    </div>
  </div>
  <div class="parameter">
    <div class="paramHeader">Wind Buffer: <span id="windBufVal"></span></div>
    <div class="paramRadio" id="windBufRadioGroup"></div>
    <div id="windBufContainer" class="paramContainer">
      <div id="windBufSlider"></div>
      <div class="paramDesc">Scales wind amplitude (Off=1.0).</div>
    </div>
  </div>

  <!-- Gravity -->
  <div class="parameter">
    <div class="paramHeader">Gravity: <span id="gravityVal"></span></div>
    <div class="paramRadio" id="gravityRadioGroup"></div>
    <div id="gravityContainer" class="paramContainer">
      <div id="gravitySlider"></div>
      <div class="paramDesc">Downward acceleration (Off=0).</div>
    </div>
  </div>

  <!-- Shading Mode -->
  <div class="parameter">
    <div class="paramHeader">Shading Mode:</div>
    <div class="paramRadio" id="shadingRadioGroup"></div>
    <div class="paramDesc">
      Gray-scale fill based on vertical position.
    </div>
  </div>

  <div class="bottomButtons">
    <button id="playPauseBtn">Pause Simulation</button>
    <button id="resetOrientationBtn">Reset Orientation</button>
    <button id="resetBtn">Reset Cloth</button>
  </div>
</div>
<div id="canvasContainer"></div>

<script>
/* -------------
   CLOTH SETUP
   ------------- */

// Grid size
let cols=20, rows=20, spacing=20;
let clothPoints=[], clothConstraints=[];
let grid=[], horizontal=[], vertical=[], centers=[];

/* SPHERE & CYLINDER */
let sphereCenter={x:0,y:0,z:0};
let sphereRadius=100;

// Cylinder: top=150, bottom=450 => cloth pinned at y=150
let cylinderTopY=150, cylinderBottomY=450, cylRadius=100;
let cylHeight=cylinderBottomY - cylinderTopY; // 300

// Simulation parameters
let damping=0.98, iterations=8;  // default iterations=8 for better collision
let stretchFactor=1.0, shearFactor=1.0, bendingFactor=1.0;
let weight=1.0;
let windX=0.2, windY=0, windZ=0.1, windBuffer=1.0;
let gravity=0.4;

// Baseline "off" values
const BASE_DAMPING=1.0, BASE_ITERATIONS=1;
const BASE_STRETCH=1.0, BASE_SHEAR=1.0, BASE_BENDING=1.0;
const BASE_WEIGHT=1.0;
const BASE_WINDX=0.0, BASE_WINDY=0.0, BASE_WINDZ=0.0, BASE_WINDBUFFER=1.0;
const BASE_GRAVITY=0.0;

// Toggles
let dampingOn=false, iterationsOn=false, stretchOn=false, shearOn=false, bendingOn=false;
let weightOn=false, windXOn=false, windYOn=false, windZOn=false, windBufOn=false, gravityOn=false;
let shadingOn=false;

// Modes
let pinningMode="top", interactionMode="rotate", simulationMode="plane", formMode="sphere";

// Positions & flags
let clothShiftX=-40;
let doResetOrientation=false, simulationRunning=true;

// Drag
let dragPointIndex=null, dragPlaneZ=0;

function setup(){
  createCanvas(windowWidth-280, windowHeight, WEBGL).parent("canvasContainer");
  createUI();
  setupCloth();
}

function createUI(){
  // EXACT UI code for radio toggles, sliders, etc.
  // Make sure no repeated "let clothConstraints" lines or braces mismatch.

  // Reset, orientation
  select("#resetBtn").mousePressed(setupCloth);
  select("#resetOrientationBtn").mousePressed(()=>{doResetOrientation=true;});
  const playPauseBtn=select("#playPauseBtn");
  playPauseBtn.mousePressed(()=>{
    simulationRunning=!simulationRunning;
    playPauseBtn.html(simulationRunning?"Pause Simulation":"Play Simulation");
  });

  // Simulation Mode
  let simRadio=createRadio();
  simRadio.option("plane","Plane");
  simRadio.option("draped","Draped");
  simRadio.selected("plane");
  simRadio.parent("simModeRadio");
  simRadio.changed(()=>{
    simulationMode=simRadio.value();
    setupCloth();
  });

  // Form Mode
  let formRadio=createRadio();
  formRadio.option("sphere","Sphere");
  formRadio.option("cylinder","Cylinder");
  formRadio.selected("sphere");
  formRadio.parent("formModeRadio");
  formRadio.changed(()=>{
    formMode=formRadio.value();
    if(simulationMode==="draped") setupCloth();
  });

  // Interaction
  let interRadio=createRadio();
  interRadio.option("rotate","Rotate");
  interRadio.option("drag","Drag");
  interRadio.selected("rotate");
  interRadio.parent("interactionRadioGroup");
  interRadio.changed(()=>{
    interactionMode=interRadio.value();
  });

  // Pinning (Plane)
  let pinRadio=createRadio();
  pinRadio.option("top","Top Pinned");
  pinRadio.option("corners","Corner Pinned");
  pinRadio.selected("top");
  pinRadio.parent("pinningRadio");
  pinRadio.changed(()=>{
    pinningMode=pinRadio.value();
    if(simulationMode==="plane") setupCloth();
  });

  // Param toggles
  function attachParamRadio(pid, setFlag, containerId){
    let r=createRadio();
    r.option("off","Off");
    r.option("on","On");
    r.parent(pid);
    r.selected("off");
    r.changed(()=>{
      let val=r.value(); let on=(val==="on");
      setFlag(on);
      if(containerId){
        if(on) select("#"+containerId).style("display","block");
        else select("#"+containerId).style("display","none");
      }
    });
  }
  attachParamRadio("dampingRadioGroup",(on)=>{dampingOn=on;},"dampingContainer");
  attachParamRadio("iterationsRadioGroup",(on)=>{iterationsOn=on;},"iterationsContainer");
  attachParamRadio("stretchRadioGroup",(on)=>{stretchOn=on;},"stretchContainer");
  attachParamRadio("shearRadioGroup",(on)=>{shearOn=on;},"shearContainer");
  attachParamRadio("bendingRadioGroup",(on)=>{bendingOn=on;},"bendingContainer");
  attachParamRadio("weightRadioGroup",(on)=>{weightOn=on;},"weightContainer");
  attachParamRadio("windXRadioGroup",(on)=>{windXOn=on;},"windXContainer");
  attachParamRadio("windYRadioGroup",(on)=>{windYOn=on;},"windYContainer");
  attachParamRadio("windZRadioGroup",(on)=>{windZOn=on;},"windZContainer");
  attachParamRadio("windBufRadioGroup",(on)=>{windBufOn=on;},"windBufContainer");
  attachParamRadio("gravityRadioGroup",(on)=>{gravityOn=on;},"gravityContainer");
  attachParamRadio("shadingRadioGroup",(on)=>{shadingOn=on;},null);

  // Sliders
  function makeSlider(divId,cb,minv,maxv,val,step){
    let s=createSlider(minv,maxv,val,step);
    s.parent(divId);
    s.input(()=>{cb(s.value());});
    cb(s.value());
  }
  makeSlider("dampingSlider",(v)=>{damping=v;select("#dampingVal").html(nf(v,1,2));},0.9,1.0,0.98,0.01);
  makeSlider("iterationsSlider",(v)=>{iterations=v;select("#iterationsVal").html(v);},1,10,8,1); 
  makeSlider("stretchSlider",(v)=>{stretchFactor=v;select("#stretchVal").html(nf(v,1,2));},0.8,1.2,1.0,0.01);
  makeSlider("shearSlider",(v)=>{shearFactor=v;select("#shearVal").html(nf(v,1,2));},0.8,1.2,1.0,0.01);
  makeSlider("bendingSlider",(v)=>{bendingFactor=v;select("#bendingVal").html(nf(v,1,2));},0.8,1.2,1.0,0.01);
  makeSlider("weightSlider",(v)=>{weight=v;select("#weightVal").html(nf(v,1,2));},0.5,2.0,1.0,0.1);
  makeSlider("windXSlider",(v)=>{windX=v;select("#windXVal").html(nf(v,1,2));},-1,1,0.2,0.01);
  makeSlider("windYSlider",(v)=>{windY=v;select("#windYVal").html(nf(v,1,2));},-1,1,0,0.01);
  makeSlider("windZSlider",(v)=>{windZ=v;select("#windZVal").html(nf(v,1,2));},-1,1,0.1,0.01);
  makeSlider("windBufSlider",(v)=>{windBuffer=v;select("#windBufVal").html(nf(v,1,2));},0,2,1.0,0.01);
  makeSlider("gravitySlider",(v)=>{gravity=v;select("#gravityVal").html(nf(v,1,2));},0,1,0.4,0.01);
}

function setupCloth(){
  clothPoints=[];
  clothConstraints=[];
  grid=[];
  horizontal=[];
  vertical=[];
  centers=[];

  let clothWidth=(cols-1)*spacing;
  let clothHeight=(rows-1)*spacing;

  if(simulationMode==="plane"){
    let startX=-clothWidth/2+clothShiftX;
    let startY=-clothHeight/2;
    createClothPoints_Plane(startX,startY,0);
  } else {
    if(formMode==="sphere"){
      sphereCenter={x:0,y:0,z:0}; sphereRadius=100;
      let startY=-sphereRadius; // pinned at y=-100
      createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);
      let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
      let cIdx=grid[midRow][midCol];
      clothPoints[cIdx].pinned=true;
      clothPoints[cIdx].x=sphereCenter.x;
      clothPoints[cIdx].y=sphereCenter.y - sphereRadius; // -100
      clothPoints[cIdx].z=sphereCenter.z;
    } else {
      // Cylinder top=150, bottom=450 => pinned at y=150
      cylinderTopY=150; cylinderBottomY=450;
      cylHeight=cylinderBottomY - cylinderTopY; // 300
      let startY=cylinderTopY; // 150
      createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);
      let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
      let cIdx=grid[midRow][midCol];
      clothPoints[cIdx].pinned=true;
      clothPoints[cIdx].x=0; clothPoints[cIdx].y=150; clothPoints[cIdx].z=0;
    }
  }
  createSubPointsAndConstraints();
}

function createClothPoints_Plane(startX,startY,startZ){
  for(let y=0;y<rows;y++){
    grid[y]=[];
    for(let x=0;x<cols;x++){
      let px=startX+x*spacing, py=startY+y*spacing, pz=startZ;
      let pinned=false;
      if(pinningMode==="top"){ pinned=(y===0); }
      else if(pinningMode==="corners"){
        pinned=((x===0&&y===0)||(x===cols-1&&y===0)||(x===0&&y===rows-1)||(x===cols-1&&y===rows-1));
      }
      clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned});
      grid[y][x]=clothPoints.length-1;
    }
  }
}

function createClothPoints_Draped(startX,fixedY,startZ){
  for(let rz=0;rz<rows;rz++){
    grid[rz]=[];
    for(let cx=0;cx<cols;cx++){
      let px=startX+cx*spacing, py=fixedY, pz=startZ+rz*spacing;
      clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned:false});
      grid[rz][cx]=clothPoints.length-1;
    }
  }
}

function createSubPointsAndConstraints(){
  horizontal=[];
  for(let y=0;y<rows;y++){
    horizontal[y]=[];
    for(let x=0;x<cols-1;x++){
      let iA=grid[y][x], iB=grid[y][x+1];
      let A=clothPoints[iA], B=clothPoints[iB];
      let mx=(A.x+B.x)*0.5, my=(A.y+B.y)*0.5, mz=(A.z+B.z)*0.5;
      clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
      horizontal[y][x]=clothPoints.length-1;
    }
  }
  vertical=[];
  for(let y=0;y<rows-1;y++){
    vertical[y]=[];
    for(let x=0;x<cols;x++){
      let iA=grid[y][x], iB=grid[y+1][x];
      let A=clothPoints[iA], B=clothPoints[iB];
      let mx=(A.x+B.x)*0.5, my=(A.y+B.y)*0.5, mz=(A.z+B.z)*0.5;
      clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
      vertical[y][x]=clothPoints.length-1;
    }
  }
  centers=[];
  for(let y=0;y<rows-1;y++){
    centers[y]=[];
    for(let x=0;x<cols-1;x++){
      let iA=grid[y][x], iB=grid[y][x+1], iC=grid[y+1][x], iD=grid[y+1][x+1];
      let A=clothPoints[iA], B=clothPoints[iB], C=clothPoints[iC], D=clothPoints[iD];
      let mx=(A.x+B.x+C.x+D.x)*0.25;
      let my=(A.y+B.y+C.y+D.y)*0.25;
      let mz=(A.z+B.z+C.z+D.z)*0.25;
      clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
      centers[y][x]=clothPoints.length-1;
    }
  }
  clothConstraints=[];

  // Structural (Stretch)
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      let idx=grid[y][x];
      if(x<cols-1){
        addConstraint(idx, grid[y][x+1], spacing*(stretchOn?stretchFactor:BASE_STRETCH));
      }
      if(y<rows-1){
        addConstraint(idx, grid[y+1][x], spacing*(stretchOn?stretchFactor:BASE_STRETCH));
      }
    }
  }
  // Bending
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols-2;x++){
      let idx1=grid[y][x], idx2=grid[y][x+2];
      addConstraint(idx1, idx2, spacing*2*(bendingOn?bendingFactor:BASE_BENDING));
    }
  }
  for(let y=0;y<rows-2;y++){
    for(let x=0;x<cols;x++){
      let idx1=grid[y][x], idx2=grid[y+2][x];
      addConstraint(idx1, idx2, spacing*2*(bendingOn?bendingFactor:BASE_BENDING));
    }
  }
  // Shear
  for(let y=0;y<rows-1;y++){
    for(let x=0;x<cols-1;x++){
      let iA=grid[y][x], iB=grid[y][x+1], iC=grid[y+1][x], iD=grid[y+1][x+1];
      addConstraint(iA,iD, sqrt(2)*spacing*(shearOn?shearFactor:BASE_SHEAR));
      addConstraint(iB,iC, sqrt(2)*spacing*(shearOn?shearFactor:BASE_SHEAR));
    }
  }
  // Subdivide each cell into 8 triangles
  function cDist(i1,i2){
    let p1=clothPoints[i1], p2=clothPoints[i2];
    let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
    return sqrt(dx*dx+dy*dy+dz*dz);
  }
  function cAdd(i1,i2){ addConstraint(i1,i2,cDist(i1,i2)); }

  for(let y=0;y<rows-1;y++){
    for(let x=0;x<cols-1;x++){
      let A=grid[y][x], B=grid[y][x+1], C=grid[y+1][x], D=grid[y+1][x+1];
      let E=horizontal[y][x], F=horizontal[y+1][x];
      let G=vertical[y][x],   H=vertical[y][x+1];
      let I=centers[y][x];

      // 8 triangles => each small triangle has constraints among 3 points
      // e.g. cAdd(A,E), cAdd(E,I), cAdd(I,A), etc.
      cAdd(A,E); cAdd(E,I); cAdd(I,A);
      cAdd(A,G); cAdd(G,I); cAdd(I,A);
      cAdd(B,E); cAdd(E,I); cAdd(I,B);
      cAdd(B,H); cAdd(H,I); cAdd(I,B);
      cAdd(C,G); cAdd(G,I); cAdd(I,C);
      cAdd(C,F); cAdd(F,I); cAdd(I,C);
      cAdd(D,H); cAdd(H,I); cAdd(I,D);
      cAdd(D,F); cAdd(F,I); cAdd(I,D);
    }
  }
}

function addConstraint(i,j,len){
  let a=min(i,j), b=max(i,j);
  for(let c of clothConstraints){
    if(c.p1===a && c.p2===b) return;
  }
  clothConstraints.push({p1:a,p2:b,length:len});
}

function draw(){
  background(30);
  if(doResetOrientation){
    // Position camera so cylinder top=150 is near top of screen
    camera(0,-200,(height/2)/tan(PI*30/180), 0,150,0, 0,1,0);
    doResetOrientation=false;
  }
  if(interactionMode==="rotate") orbitControl();
  if(simulationRunning) updateCloth();

  // Draw sphere or cylinder in draped mode
  if(simulationMode==="draped"){
    noStroke(); fill("#222");
    if(formMode==="sphere"){
      push();
      translate(sphereCenter.x,sphereCenter.y,sphereCenter.z);
      sphere(sphereRadius);
      pop();
    } else {
      // Cylinder top=150, bottom=450 => midpoint=300
      push();
      let midY=(cylinderTopY+cylinderBottomY)*0.5; // 300
      translate(0, midY, 0);
      cylinder(cylRadius, cylHeight);
      pop();
    }
  }

  // Shading mode
  if(shadingOn){
    let minY=Infinity, maxY=-Infinity;
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        let pt=clothPoints[grid[y][x]];
        if(pt.y<minY) minY=pt.y;
        if(pt.y>maxY) maxY=pt.y;
      }
    }
    noStroke();
    for(let y=0;y<rows-1;y++){
      for(let x=0;x<cols-1;x++){
        let A=clothPoints[grid[y][x]];
        let B=clothPoints[grid[y][x+1]];
        let C=clothPoints[grid[y+1][x+1]];
        let D=clothPoints[grid[y+1][x]];
        let avgY=(A.y+B.y+C.y+D.y)*0.25;
        let bright=map(avgY, minY, maxY, 220,80);
        fill(bright);
        beginShape();
        vertex(A.x,A.y,A.z);
        vertex(B.x,B.y,B.z);
        vertex(C.x,C.y,C.z);
        vertex(D.x,D.y,D.z);
        endShape(CLOSE);
      }
    }
  }

  // Wireframe constraints
  stroke(255); strokeWeight(2);
  for(let c of clothConstraints){
    let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
    line(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z);
  }

  // Cloth points
  noStroke(); fill("#FF0000");
  for(let p of clothPoints){
    push();
    translate(p.x,p.y,p.z);
    sphere(2);
    pop();
  }
}

function updateCloth(){
  let freq=0.01;
  for(let p of clothPoints){
    if(!p.pinned){
      let vx=(p.x-p.oldx)*(dampingOn?damping:BASE_DAMPING);
      let vy=(p.y-p.oldy)*(dampingOn?damping:BASE_DAMPING);
      let vz=(p.z-p.oldz)*(dampingOn?damping:BASE_DAMPING);
      p.oldx=p.x; p.oldy=p.y; p.oldz=p.z;

      let sinVal=sin(frameCount*freq);
      let effWindX= windXOn? (windBuffer*windX*sinVal) : BASE_WINDX;
      let effWindY= windYOn? (windBuffer*windY*sinVal) : BASE_WINDY;
      let effWindZ= windZOn? (windBuffer*windZ*sinVal) : BASE_WINDZ;

      let effGrav= gravityOn? gravity : BASE_GRAVITY;
      let effWeight= weightOn? weight : BASE_WEIGHT;

      p.x += vx + effWindX;
      p.y += vy + effGrav*effWeight + effWindY;
      p.z += vz + effWindZ;
    }
  }
  let effIter= iterationsOn? iterations : BASE_ITERATIONS;
  for(let i=0;i<effIter;i++){
    for(let c of clothConstraints){
      let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
      let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
      let distVal=sqrt(dx*dx+dy*dy+dz*dz);
      let diff=(distVal-c.length)/distVal;
      let offsetX=dx*0.5*diff, offsetY=dy*0.5*diff, offsetZ=dz*0.5*diff;
      if(!p1.pinned){
        p1.x+=offsetX; p1.y+=offsetY; p1.z+=offsetZ;
      }
      if(!p2.pinned){
        p2.x-=offsetX; p2.y-=offsetY; p2.z-=offsetZ;
      }
    }
  }
  doSelfCollision();

  if(simulationMode==="draped"){
    if(formMode==="sphere") doSphereCollision();
    else if(formMode==="cylinder") doCylinderCollision();
    doCeilingClamp();   // clamp if cloth tries to go above y=150
    doFloorClamp();     // clamp if cloth tries to go below y=450
  }
}

function doSelfCollision(){
  let threshold= spacing*0.5;
  for(let i=0;i<clothPoints.length;i++){
    for(let j=i+1;j<clothPoints.length;j++){
      let p1=clothPoints[i], p2=clothPoints[j];
      let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
      let d=sqrt(dx*dx+dy*dy+dz*dz);
      if(d<threshold && d>0){
        let overlap=threshold-d;
        let angle=atan2(dy,dx);
        if(!p1.pinned && !p2.pinned){
          p1.x-=cos(angle)*overlap*0.5; p1.y-=sin(angle)*overlap*0.5;
          p2.x+=cos(angle)*overlap*0.5; p2.y+=sin(angle)*overlap*0.5;
        } else if(!p1.pinned && p2.pinned){
          p1.x-=cos(angle)*overlap; p1.y-=sin(angle)*overlap;
        } else if(p1.pinned && !p2.pinned){
          p2.x+=cos(angle)*overlap; p2.y+=sin(angle)*overlap;
        }
      }
    }
  }
}

function doSphereCollision(){
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned){
      let dx=p.x-sphereCenter.x, dy=p.y-sphereCenter.y, dz=p.z-sphereCenter.z;
      let distVal=sqrt(dx*dx+dy*dy+dz*dz);
      if(distVal< sphereRadius){
        let overlap=sphereRadius-distVal;
        let nx=dx/distVal, ny=dy/distVal, nz=dz/distVal;
        p.x+=nx*overlap; p.y+=ny*overlap; p.z+=nz*overlap;
        p.oldx=p.x - friction*(p.x-p.oldx);
        p.oldy=p.y - friction*(p.y-p.oldy);
        p.oldz=p.z - friction*(p.z-p.oldz);
      }
    }
  }
}

function doCylinderCollision(){
  // Cylinder top=150, bottom=450 => if 150<=p.y<=450, check radial
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned && p.y>=cylinderTopY && p.y<=cylinderBottomY){
      let r=sqrt(p.x*p.x + p.z*p.z);
      if(r< cylRadius){
        let overlap=cylRadius-r;
        let nx=p.x/r, nz=p.z/r;
        p.x+=nx*overlap; p.z+=nz*overlap;
        p.oldx=p.x - friction*(p.x-p.oldx);
        p.oldz=p.z - friction*(p.z-p.oldz);
      }
    }
  }
}

// If cloth tries to go above y=150, clamp it
function doCeilingClamp(){
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned && p.y< cylinderTopY){
      p.y= cylinderTopY;
      p.oldy= p.y + friction*(p.oldy - p.y);
    }
  }
}

// If cloth tries to go below y=450, clamp it
function doFloorClamp(){
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned && p.y> cylinderBottomY){
      p.y= cylinderBottomY;
      p.oldy= p.y - friction*(p.y - p.oldy);
    }
  }
}

function mousePressed(){
  if(interactionMode==="drag"){
    let closest=null,closestDist=10;
    for(let i=0;i<clothPoints.length;i++){
      let p=clothPoints[i];
      let sx=modelX(p.x,p.y,p.z), sy=modelY(p.x,p.y,p.z);
      let d=dist(mouseX,mouseY,sx,sy);
      if(d<closestDist){closestDist=d;closest=i;}
    }
    if(closest!==null){
      dragPointIndex=closest;
      dragPlaneZ=clothPoints[closest].z;
    }
  }
}

function mouseDragged(){
  if(interactionMode==="drag" && dragPointIndex!==null){
    let newPos=unproject(mouseX,mouseY,dragPlaneZ);
    let p=clothPoints[dragPointIndex];
    p.x=newPos.x; p.y=newPos.y;
    p.oldx=newPos.x; p.oldy=newPos.y;
  }
}

function mouseReleased(){
  dragPointIndex=null;
}

function unproject(mx,my,fz){
  let d=(height/2)/tan(PI*30/180);
  let nx=mx-width/2, ny=my-height/2;
  let factor=(d+fz)/d;
  return createVector(nx*factor, ny*factor, fz);
}

function windowResized(){
  resizeCanvas(windowWidth-280,windowHeight);
}
</script>
</body>
</html>
