<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Cloth Simulation â€“ Plane & Draped (Sphere or Cylinder)</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
  <style>
    body, html {
      margin: 0; padding: 0;
      background: #111; color: #fff;
      font-family: sans-serif;
      height: 100%;
    }
    #uiPanel {
      position: absolute; top: 0; left: 0;
      width: 280px; height: 100%;
      background: #222; color: #fff;
      padding: 20px; box-sizing: border-box;
      overflow-y: auto;
      box-shadow: 2px 0 8px rgba(0,0,0,0.5);
    }
    #canvasContainer {
      position: absolute; top: 0; left: 280px;
      width: calc(100% - 280px); height: 100%;
      overflow: hidden;
    }
    h2 { margin-top: 0; }
    p, label { font-size: 14px; line-height: 1.4em; margin-bottom: 8px; }
    .parameter {
      margin-bottom: 12px; padding-bottom: 8px;
      border-bottom: 1px solid #333;
    }
    .paramHeader { margin-bottom: 4px; font-weight: bold; }
    .paramRadio { display: flex; gap: 8px; margin-bottom: 4px; }
    .paramRadio input[type="radio"] { accent-color: #1e90ff; }
    input[type="range"] { accent-color: #1e90ff; }
    .paramContainer { display: none; margin-top: 4px; }
    .paramDesc { font-size: 12px; color: #aaa; margin-top: 4px; }
    .bottomButtons {
      position: sticky; bottom: 20px; width: 100%;
    }
    button {
      width: 100%; padding: 8px 12px; background: #555; color: #fff;
      border: none; cursor: pointer; margin-bottom: 10px;
    }
    button:hover { background: #666; }
  </style>
</head>
<body>
<div id="uiPanel">
  <h2>3D Cloth Simulation</h2>
  <p>
    Two main simulation modes: <strong>Plane</strong> or <strong>Draped</strong>.<br>
    In Draped mode, choose <strong>Sphere</strong> or <strong>Cylinder</strong> (dark gray) as the form.
  </p>

  <div class="parameter">
    <div class="paramHeader">Simulation Mode:</div>
    <div id="simModeRadio"></div>
    <div class="paramDesc">
      <strong>Plane</strong>: pinned cloth in free space.<br>
      <strong>Draped</strong>: cloth drapes over a form.
    </div>
  </div>

  <div class="parameter" id="formModeParam">
    <div class="paramHeader">Form Mode:</div>
    <div id="formModeRadio"></div>
    <div class="paramDesc">
      Choose <strong>Sphere</strong> or <strong>Cylinder</strong>.
    </div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Interaction Mode:</div>
    <div id="interactionRadioGroup"></div>
    <div class="paramDesc">
      "Rotate" = move camera; "Drag" = pick cloth points.<br>
      (Use "Reset Orientation" after loading.)
    </div>
  </div>

  <div class="parameter">
    <div class="paramHeader">Pinning Mode:</div>
    <div id="pinningRadio"></div>
    <div class="paramDesc">Only for Plane mode.</div>
  </div>

  <!-- Add your Damping, Iterations, Stretch, Shear, Bending, Weight, Wind, etc. -->
  <!-- ... identical to the code you've been using ... -->
  <!-- For brevity, here's the short version, but copy your full UI from before. -->

  <div class="parameter">
    <div class="paramHeader">Gravity: <span id="gravityVal"></span></div>
    <div class="paramRadio" id="gravityRadioGroup"></div>
    <div id="gravityContainer" class="paramContainer">
      <div id="gravitySlider"></div>
      <div class="paramDesc">Downward acceleration (Off=0).</div>
    </div>
  </div>

  <div class="bottomButtons">
    <button id="playPauseBtn">Pause Simulation</button>
    <button id="resetOrientationBtn">Reset Orientation</button>
    <button id="resetBtn">Reset Cloth</button>
  </div>
</div>

<div id="canvasContainer"></div>

<script>
/* CLOTH & SHAPE SETUP */
let cols=20, rows=20, spacing=20;
let clothPoints=[], clothConstraints=[];
let grid=[], horizontal=[], vertical=[], centers=[];

/* SPHERE for Draped mode */
let sphereCenter={x:0,y:0,z:0};
let sphereRadius=100;

/* CYLINDER for Draped mode:
   We define "top" at y=150, bottom at y=450.
   This way the cloth is pinned at y=150 and falls down to y=450 with positive gravity. */
let cylinderTopY=150;
let cylinderBottomY=450;
let cylRadius=100;
let cylHeight=cylinderBottomY - cylinderTopY; // 450 - 150=300

/* SIM PARAMS (default) */
let damping=0.98, iterations=5, stretchFactor=1.0, shearFactor=1.0, bendingFactor=1.0;
let weight=1.0, windX=0.2, windY=0, windZ=0.1, windBuffer=1.0, gravity=0.4;

/* "Off" baselines */
const BASE_DAMPING=1.0, BASE_ITERATIONS=1, BASE_STRETCH=1.0, BASE_SHEAR=1.0, BASE_BENDING=1.0;
const BASE_WEIGHT=1.0, BASE_WINDX=0.0, BASE_WINDY=0.0, BASE_WINDZ=0.0, BASE_WINDBUFFER=1.0, BASE_GRAVITY=0.0;

/* Toggles */
let dampingOn=false, iterationsOn=false, stretchOn=false, shearOn=false, bendingOn=false;
let weightOn=false, windXOn=false, windYOn=false, windZOn=false, windBufOn=false, gravityOn=false, shadingOn=false;

/* MODES */
let pinningMode="top", interactionMode="rotate", simulationMode="plane", formMode="sphere";

/* SHIFT & FLAGS */
let clothShiftX=-40;
let doResetOrientation=false, simulationRunning=true;
let dragPointIndex=null, dragPlaneZ=0;

function setup(){
  createCanvas(windowWidth-280,windowHeight,WEBGL).parent("canvasContainer");
  createUI();
  setupCloth();
}

function createUI(){
  // Similar to your existing UI code for toggles/sliders
  // ...
  // Make sure you only declare clothConstraints once, etc.
}

function setupCloth(){
  clothPoints=[];
  clothConstraints=[];
  grid=[];
  horizontal=[];
  vertical=[];
  centers=[];

  let clothWidth=(cols-1)*spacing;
  let clothHeight=(rows-1)*spacing;

  if(simulationMode==="plane"){
    let startX=-clothWidth/2+clothShiftX;
    let startY=-clothHeight/2;
    createClothPoints_Plane(startX,startY,0);
  } else {
    // Draped mode
    if(formMode==="sphere"){
      sphereCenter={x:0,y:0,z:0};
      sphereRadius=100;
      let startY=-sphereRadius; // pinned at y=-100
      createClothPoints_Draped(-clothWidth/2, startY, -clothHeight/2);
      // Pin center at sphere top => y=-100
      let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
      let centerIdx=grid[midRow][midCol];
      clothPoints[centerIdx].pinned=true;
      clothPoints[centerIdx].x=sphereCenter.x;
      clothPoints[centerIdx].y=sphereCenter.y - sphereRadius;
      clothPoints[centerIdx].z=sphereCenter.z;
    } else {
      // Cylinder from y=150 (top) down to y=450 (bottom)
      // Cloth pinned at y=150 so it can "fall" to 450 with positive gravity
      cylinderTopY=150;
      cylinderBottomY=450;
      cylHeight=cylinderBottomY - cylinderTopY; // 300
      let startY=cylinderTopY; // 150
      createClothPoints_Draped(-clothWidth/2, startY, -clothHeight/2);

      let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
      let centerIdx=grid[midRow][midCol];
      clothPoints[centerIdx].pinned=true;
      clothPoints[centerIdx].x=0;
      clothPoints[centerIdx].y=cylinderTopY; // 150
      clothPoints[centerIdx].z=0;
    }
  }
  createSubPointsAndConstraints();
}

function createClothPoints_Plane(startX,startY,startZ){
  for(let y=0;y<rows;y++){
    grid[y]=[];
    for(let x=0;x<cols;x++){
      let px=startX+x*spacing, py=startY+y*spacing, pz=startZ;
      let pinned=false;
      if(pinningMode==="top"){ pinned=(y===0); }
      else if(pinningMode==="corners"){
        pinned=((x===0&&y===0)||(x===cols-1&&y===0)||(x===0&&y===rows-1)||(x===cols-1&&y===rows-1));
      }
      clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned});
      grid[y][x]=clothPoints.length-1;
    }
  }
}

function createClothPoints_Draped(startX,fixedY,startZ){
  for(let rz=0;rz<rows;rz++){
    grid[rz]=[];
    for(let cx=0;cx<cols;cx++){
      let px=startX+cx*spacing, py=fixedY, pz=startZ+rz*spacing;
      clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned:false});
      grid[rz][cx]=clothPoints.length-1;
    }
  }
}

function createSubPointsAndConstraints(){
  // (Same as your subdiv code: horizontal, vertical, centers, then constraints)
  // ...
}

function draw(){
  background(30);
  if(doResetOrientation){
    // Shift camera upward so cylinder is higher on screen
    camera(0,-200,(height/2)/tan(PI*30/180),  0,150,0,  0,1,0);
    doResetOrientation=false;
  }
  if(interactionMode==="rotate") orbitControl();
  if(simulationRunning) updateCloth();

  if(simulationMode==="draped"){
    noStroke(); fill("#222");
    if(formMode==="sphere"){
      push();
      translate(sphereCenter.x,sphereCenter.y,sphereCenter.z);
      sphere(sphereRadius);
      pop();
    } else {
      // Cylinder top=150, bottom=450 => midpoint=300
      push();
      translate(0,(cylinderTopY+cylinderBottomY)*0.5,0); // y=300
      cylinder(cylRadius,cylHeight);
      pop();
    }
  }
  // (Render cloth wireframe + points, shading if shadingOn, etc.)
  // ...
}

function updateCloth(){
  // (Same as your existing update code, but no "floor collision" that clamps y>150.
  //  Instead, we want a "ceiling collision" that clamps y < 150, because 150 is "above".)
  // ...
  for(let p of clothPoints){
    if(!p.pinned){
      let vx=(p.x-p.oldx)*(dampingOn?damping:1.0);
      let vy=(p.y-p.oldy)*(dampingOn?damping:1.0);
      let vz=(p.z-p.oldz)*(dampingOn?damping:1.0);
      p.oldx=p.x; p.oldy=p.y; p.oldz=p.z;
      // wind, gravity, etc.
      // ...
      p.x+= vx + /* windX logic */;
      p.y+= vy + (gravityOn?gravity:0)*(weightOn?weight:1.0) + /* windY logic */;
      p.z+= vz + /* windZ logic */;
    }
  }
  // constraints, selfCollision, then doSphereCollision or doCylinderCollision
  // ...
  if(simulationMode==="draped"){
    if(formMode==="sphere") doSphereCollision();
    else doCylinderCollision();
    // Instead of doFloorCollision => doCeilingCollision if y < cylinderTopY => clamp
    doCeilingCollision();
  }
}

function doCeilingCollision(){
  // If cloth tries to go "above" y=150, clamp it
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned && p.y< cylinderTopY){
      p.y= cylinderTopY; // clamp to 150
      p.oldy= p.y + friction*(p.oldy-p.y);
    }
  }
}

function doCylinderCollision(){
  const friction=0.5;
  for(let p of clothPoints){
    if(!p.pinned){
      // cylinder from y=150 to y=450
      if(p.y>=cylinderTopY && p.y<=cylinderBottomY){
        let r= sqrt(p.x*p.x + p.z*p.z);
        if(r< cylRadius){
          let overlap= cylRadius-r;
          let nx= p.x/r, nz= p.z/r;
          p.x+= nx*overlap;
          p.z+= nz*overlap;
          // friction
          p.oldx= p.x - friction*(p.x-p.oldx);
          p.oldz= p.z - friction*(p.z-p.oldz);
        }
      }
    }
  }
}
</script>
</body>
</html>
