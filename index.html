<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Cloth Simulation – Plane & Draped (Sphere or Cylinder)</title>
    <!-- p5.js library -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
    <style>
      /* Global Layout & Colors */
      body, html {
        margin: 0;
        padding: 0;
        background: #111;
        color: #fff;
        font-family: sans-serif;
        height: 100%;
      }
      #uiPanel {
        position: absolute;
        top: 0;
        left: 0;
        width: 280px;
        height: 100%;
        background: #222;
        box-shadow: 2px 0 8px rgba(0,0,0,0.5);
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
      }
      #canvasContainer {
        position: absolute;
        top: 0;
        left: 280px;
        width: calc(100% - 280px);
        height: 100%;
        overflow: hidden;
      }
      h2 {
        margin-top: 0;
      }
      p, label {
        font-size: 14px;
        line-height: 1.4em;
        margin-bottom: 8px;
      }
      .parameter {
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid #333;
      }
      .paramHeader {
        margin-bottom: 4px;
        font-weight: bold;
      }
      .paramRadio {
        display: flex;
        gap: 8px;
        margin-bottom: 4px;
      }
      /* Use Dodger Blue (#1e90ff) for radios and sliders */
      .paramRadio input[type="radio"] {
        accent-color: #1e90ff;
      }
      input[type="range"] {
        accent-color: #1e90ff;
      }
      .paramContainer {
        margin-top: 4px;
        display: none; /* Hidden until "On" is selected */
      }
      .paramDesc {
        font-size: 12px;
        color: #aaa;
        margin-top: 4px;
      }
      .bottomButtons {
        position: sticky;
        bottom: 20px;
        width: 100%;
      }
      button {
        width: 100%;
        padding: 8px 12px;
        background: #555;
        color: #fff;
        border: none;
        cursor: pointer;
        margin-bottom: 10px;
      }
      button:hover {
        background: #666;
      }
    </style>
  </head>
  <body>
    <!-- UI Panel -->
    <div id="uiPanel">
      <h2>3D Cloth Simulation</h2>
      <p>
        Two main simulation modes: <strong>Plane</strong> or <strong>Draped</strong>.<br>
        In Draped mode, choose <strong>Sphere</strong> or <strong>Cylinder</strong> (dark gray) as the form.
      </p>

      <!-- Simulation Mode -->
      <div class="parameter">
        <div class="paramHeader">Simulation Mode:</div>
        <div id="simModeRadio"></div>
        <div class="paramDesc">
          <strong>Plane</strong>: pinned cloth in free space.<br>
          <strong>Draped</strong>: cloth drapes over a form (sphere or cylinder).
        </div>
      </div>

      <!-- Form Mode (only relevant in Draped mode) -->
      <div class="parameter" id="formModeParam">
        <div class="paramHeader">Form Mode:</div>
        <div id="formModeRadio"></div>
        <div class="paramDesc">
          Choose <strong>Sphere</strong> or <strong>Cylinder</strong>.
        </div>
      </div>

      <!-- Interaction Mode -->
      <div class="parameter">
        <div class="paramHeader">Interaction Mode:</div>
        <div id="interactionRadioGroup"></div>
        <div class="paramDesc">
          "Rotate" = move the camera; "Drag" = pick cloth points.<br>
          (Use "Reset Orientation" for best dragging.)
        </div>
      </div>

      <!-- Pinning Mode (Plane only) -->
      <div class="parameter">
        <div class="paramHeader">Pinning Mode:</div>
        <div id="pinningRadio"></div>
        <div class="paramDesc">Only relevant in Plane mode.</div>
      </div>

      <!-- Damping -->
      <div class="parameter">
        <div class="paramHeader">Damping: <span id="dampingVal"></span></div>
        <div class="paramRadio" id="dampingRadioGroup"></div>
        <div id="dampingContainer" class="paramContainer">
          <div id="dampingSlider"></div>
          <div class="paramDesc">Controls energy loss (Off=1.0).</div>
        </div>
      </div>

      <!-- Iterations -->
      <div class="parameter">
        <div class="paramHeader">Iterations: <span id="iterationsVal"></span></div>
        <div class="paramRadio" id="iterationsRadioGroup"></div>
        <div id="iterationsContainer" class="paramContainer">
          <div id="iterationsSlider"></div>
          <div class="paramDesc">Constraint relaxations per frame (Off=1).</div>
        </div>
      </div>

      <!-- Stretch -->
      <div class="parameter">
        <div class="paramHeader">Stretch: <span id="stretchVal"></span></div>
        <div class="paramRadio" id="stretchRadioGroup"></div>
        <div id="stretchContainer" class="paramContainer">
          <div id="stretchSlider"></div>
          <div class="paramDesc">Affects cloth extension (Off=1.0).</div>
        </div>
      </div>

      <!-- Shear -->
      <div class="parameter">
        <div class="paramHeader">Shear: <span id="shearVal"></span></div>
        <div class="paramRadio" id="shearRadioGroup"></div>
        <div id="shearContainer" class="paramContainer">
          <div id="shearSlider"></div>
          <div class="paramDesc">Resists diagonal distortion (Off=1.0).</div>
        </div>
      </div>

      <!-- Bending -->
      <div class="parameter">
        <div class="paramHeader">Bending: <span id="bendingVal"></span></div>
        <div class="paramRadio" id="bendingRadioGroup"></div>
        <div id="bendingContainer" class="paramContainer">
          <div id="bendingSlider"></div>
          <div class="paramDesc">Resistance to sharp folds (Off=1.0).</div>
        </div>
      </div>

      <!-- Weight -->
      <div class="parameter">
        <div class="paramHeader">Weight: <span id="weightVal"></span></div>
        <div class="paramRadio" id="weightRadioGroup"></div>
        <div id="weightContainer" class="paramContainer">
          <div id="weightSlider"></div>
          <div class="paramDesc">Downward pull (Off=1.0).</div>
        </div>
      </div>

      <!-- Wind X -->
      <div class="parameter">
        <div class="paramHeader">Wind X: <span id="windXVal"></span></div>
        <div class="paramRadio" id="windXRadioGroup"></div>
        <div id="windXContainer" class="paramContainer">
          <div id="windXSlider"></div>
          <div class="paramDesc">Wind force along X (Off=0).</div>
        </div>
      </div>

      <!-- Wind Y -->
      <div class="parameter">
        <div class="paramHeader">Wind Y: <span id="windYVal"></span></div>
        <div class="paramRadio" id="windYRadioGroup"></div>
        <div id="windYContainer" class="paramContainer">
          <div id="windYSlider"></div>
          <div class="paramDesc">Wind force along Y (Off=0).</div>
        </div>
      </div>

      <!-- Wind Z -->
      <div class="parameter">
        <div class="paramHeader">Wind Z: <span id="windZVal"></span></div>
        <div class="paramRadio" id="windZRadioGroup"></div>
        <div id="windZContainer" class="paramContainer">
          <div id="windZSlider"></div>
          <div class="paramDesc">Wind force along Z (Off=0).</div>
        </div>
      </div>

      <!-- Wind Buffer -->
      <div class="parameter">
        <div class="paramHeader">Wind Buffer: <span id="windBufVal"></span></div>
        <div class="paramRadio" id="windBufRadioGroup"></div>
        <div id="windBufContainer" class="paramContainer">
          <div id="windBufSlider"></div>
          <div class="paramDesc">Scales overall wind amplitude (Off=1.0).</div>
        </div>
      </div>

      <!-- Gravity -->
      <div class="parameter">
        <div class="paramHeader">Gravity: <span id="gravityVal"></span></div>
        <div class="paramRadio" id="gravityRadioGroup"></div>
        <div id="gravityContainer" class="paramContainer">
          <div id="gravitySlider"></div>
          <div class="paramDesc">Downward acceleration (Off=0).</div>
        </div>
      </div>

      <!-- Shading Mode -->
      <div class="parameter">
        <div class="paramHeader">Shading Mode:</div>
        <div class="paramRadio" id="shadingRadioGroup"></div>
        <div class="paramDesc">
          Gray-scale fill based on vertical position.
        </div>
      </div>

      <div class="bottomButtons">
        <button id="playPauseBtn">Pause Simulation</button>
        <button id="resetOrientationBtn">Reset Orientation</button>
        <button id="resetBtn">Reset Cloth</button>
      </div>
    </div>

    <div id="canvasContainer"></div>

    <script>
      /* ----------------------------
       * CLOTH & SHAPES CONFIGURATION
       * ---------------------------- */

      let cols = 20, rows = 20, spacing = 20;
      let clothPoints = [], clothConstraints = [];
      let grid = [], horizontal = [], vertical = [], centers = [];

      // Sphere for Draped mode
      let sphereCenter = { x: 0, y: 0, z: 0 };
      let sphereRadius = 100;

      // Cylinder for Draped mode: top=150, bottom=450 => cloth pinned at y=150
      // Gravity pulls it "down" toward y=450.
      let cylinderTopY = 150;
      let cylinderBottomY = 450;
      let cylRadius = 100;
      let cylHeight = cylinderBottomY - cylinderTopY; // 300

      // Simulation parameters (defaults)
      let damping = 0.98;
      let iterations = 5;
      let stretchFactor = 1.0;
      let shearFactor = 1.0;
      let bendingFactor = 1.0;
      let weight = 1.0;
      let windX = 0.2, windY = 0, windZ = 0.1;
      let windBuffer = 1.0;
      let gravity = 0.4;

      // "Off" baselines
      const BASE_DAMPING=1.0, BASE_ITERATIONS=1, BASE_STRETCH=1.0, BASE_SHEAR=1.0, BASE_BENDING=1.0;
      const BASE_WEIGHT=1.0, BASE_WINDX=0.0, BASE_WINDY=0.0, BASE_WINDZ=0.0, BASE_WINDBUFFER=1.0, BASE_GRAVITY=0.0;

      // Toggles
      let dampingOn=false, iterationsOn=false, stretchOn=false, shearOn=false, bendingOn=false;
      let weightOn=false, windXOn=false, windYOn=false, windZOn=false, windBufOn=false, gravityOn=false;
      let shadingOn=false;

      // Modes
      let pinningMode="top";   // For Plane
      let interactionMode="rotate"; 
      let simulationMode="plane"; // "plane" or "draped"
      let formMode="sphere";   // "sphere" or "cylinder"

      // Shift & flags
      let clothShiftX=-40;
      let doResetOrientation=false;
      let simulationRunning=true;

      // 3D Dragging
      let dragPointIndex=null, dragPlaneZ=0;

      function setup() {
        let cnv = createCanvas(windowWidth - 280, windowHeight, WEBGL);
        cnv.parent("canvasContainer");
        cnv.style("display","block");
        createUI();
        setupCloth();
      }

      function createUI(){
        // Attach your radio toggles, sliders, etc.
        // (Identical to the code you had for toggles.)
        // For brevity, we’ll show a short version. 
        // Make sure you have no duplicate declarations of clothConstraints, etc.
        
        // Reset Cloth & Orientation
        select("#resetBtn").mousePressed(setupCloth);
        select("#resetOrientationBtn").mousePressed(()=>{ doResetOrientation=true; });
        const playPauseBtn = select("#playPauseBtn");
        playPauseBtn.mousePressed(()=>{
          simulationRunning=!simulationRunning;
          playPauseBtn.html(simulationRunning?"Pause Simulation":"Play Simulation");
        });

        // Simulation Mode
        let simModeRadio=createRadio();
        simModeRadio.option("plane","Plane");
        simModeRadio.option("draped","Draped");
        simModeRadio.selected("plane");
        simModeRadio.parent("simModeRadio");
        simModeRadio.changed(()=>{
          simulationMode=simModeRadio.value();
          setupCloth();
        });

        // Form Mode
        let formModeRadio=createRadio();
        formModeRadio.option("sphere","Sphere");
        formModeRadio.option("cylinder","Cylinder");
        formModeRadio.selected("sphere");
        formModeRadio.parent("formModeRadio");
        formModeRadio.changed(()=>{
          formMode=formModeRadio.value();
          if(simulationMode==="draped") setupCloth();
        });

        // Interaction Mode
        let interactionRadio=createRadio();
        interactionRadio.option("rotate","Rotate");
        interactionRadio.option("drag","Drag");
        interactionRadio.selected("rotate");
        interactionRadio.parent("interactionRadioGroup");
        interactionRadio.changed(()=>{
          interactionMode=interactionRadio.value();
        });

        // Pinning Mode (Plane)
        let pinRadio=createRadio();
        pinRadio.option("top","Top Pinned");
        pinRadio.option("corners","Corner Pinned");
        pinRadio.selected("top");
        pinRadio.parent("pinningRadio");
        pinRadio.changed(()=>{
          pinningMode=pinRadio.value();
          if(simulationMode==="plane") setupCloth();
        });

        // Helper for toggles
        function attachParamRadio(parentId,setFlag,containerId){
          let r=createRadio();
          r.option("off","Off");
          r.option("on","On");
          r.parent(parentId);
          r.selected("off");
          r.changed(()=>{
            let val=r.value();
            let on=(val==="on");
            setFlag(on);
            if(containerId){
              if(on) select("#"+containerId).style("display","block");
              else select("#"+containerId).style("display","none");
            }
          });
        }
        attachParamRadio("dampingRadioGroup",(on)=>{dampingOn=on;},"dampingContainer");
        attachParamRadio("iterationsRadioGroup",(on)=>{iterationsOn=on;},"iterationsContainer");
        attachParamRadio("stretchRadioGroup",(on)=>{stretchOn=on;},"stretchContainer");
        attachParamRadio("shearRadioGroup",(on)=>{shearOn=on;},"shearContainer");
        attachParamRadio("bendingRadioGroup",(on)=>{bendingOn=on;},"bendingContainer");
        attachParamRadio("weightRadioGroup",(on)=>{weightOn=on;},"weightContainer");
        attachParamRadio("windXRadioGroup",(on)=>{windXOn=on;},"windXContainer");
        attachParamRadio("windYRadioGroup",(on)=>{windYOn=on;},"windYContainer");
        attachParamRadio("windZRadioGroup",(on)=>{windZOn=on;},"windZContainer");
        attachParamRadio("windBufRadioGroup",(on)=>{windBufOn=on;},"windBufContainer");
        attachParamRadio("gravityRadioGroup",(on)=>{gravityOn=on;},"gravityContainer");
        attachParamRadio("shadingRadioGroup",(on)=>{shadingOn=on;},null);

        // Helper for sliders
        function createSliderAndLabel(divId,callback,min,max,val,step){
          const slider=createSlider(min,max,val,step);
          slider.parent(divId);
          slider.input(()=>{callback(slider.value());});
          callback(slider.value());
        }
        createSliderAndLabel("dampingSlider",(v)=>{damping=v;select("#dampingVal").html(nf(v,1,2));},0.90,1.0,0.98,0.01);
        createSliderAndLabel("iterationsSlider",(v)=>{iterations=v;select("#iterationsVal").html(v);},1,10,5,1);
        createSliderAndLabel("stretchSlider",(v)=>{stretchFactor=v;select("#stretchVal").html(nf(v,1,2));},0.8,1.2,1.0,0.01);
        createSliderAndLabel("shearSlider",(v)=>{shearFactor=v;select("#shearVal").html(nf(v,1,2));},0.8,1.2,1.0,0.01);
        createSliderAndLabel("bendingSlider",(v)=>{bendingFactor=v;select("#bendingVal").html(nf(v,1,2));},0.8,1.2,1.0,0.01);
        createSliderAndLabel("weightSlider",(v)=>{weight=v;select("#weightVal").html(nf(v,1,2));},0.5,2.0,1.0,0.1);
        createSliderAndLabel("windXSlider",(v)=>{windX=v;select("#windXVal").html(nf(v,1,2));},-1,1,0.2,0.01);
        createSliderAndLabel("windYSlider",(v)=>{windY=v;select("#windYVal").html(nf(v,1,2));},-1,1,0,0.01);
        createSliderAndLabel("windZSlider",(v)=>{windZ=v;select("#windZVal").html(nf(v,1,2));},-1,1,0.1,0.01);
        createSliderAndLabel("windBufSlider",(v)=>{windBuffer=v;select("#windBufVal").html(nf(v,1,2));},0,2,1.0,0.01);
        createSliderAndLabel("gravitySlider",(v)=>{gravity=v;select("#gravityVal").html(nf(v,1,2));},0,1,0.4,0.01);
      }

      function setupCloth(){
        clothPoints=[];
        clothConstraints=[];
        grid=[];
        horizontal=[];
        vertical=[];
        centers=[];

        let clothWidth=(cols-1)*spacing;
        let clothHeight=(rows-1)*spacing;

        if(simulationMode==="plane"){
          let startX=-clothWidth/2+clothShiftX;
          let startY=-clothHeight/2;
          createClothPoints_Plane(startX,startY,0);
        } else {
          if(formMode==="sphere"){
            sphereCenter={x:0,y:0,z:0};
            sphereRadius=100;
            let startY=-sphereRadius; // pinned at y=-100
            createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);

            let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
            let centerIdx=grid[midRow][midCol];
            clothPoints[centerIdx].pinned=true;
            clothPoints[centerIdx].x= sphereCenter.x;
            clothPoints[centerIdx].y= sphereCenter.y - sphereRadius; // -100
            clothPoints[centerIdx].z= sphereCenter.z;
          } else {
            // Cylinder top=150, bottom=450 => pinned at y=150
            cylinderTopY=150;
            cylinderBottomY=450;
            cylHeight= cylinderBottomY - cylinderTopY; // 300
            let startY=cylinderTopY; // 150
            createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);

            let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
            let centerIdx=grid[midRow][midCol];
            clothPoints[centerIdx].pinned=true;
            clothPoints[centerIdx].x=0;
            clothPoints[centerIdx].y=cylinderTopY; // 150
            clothPoints[centerIdx].z=0;
          }
        }
        createSubPointsAndConstraints();
      }

      function createClothPoints_Plane(startX,startY,startZ){
        for(let y=0;y<rows;y++){
          grid[y]=[];
          for(let x=0;x<cols;x++){
            let px=startX+x*spacing, py=startY+y*spacing, pz=startZ;
            let pinned=false;
            if(pinningMode==="top"){
              pinned=(y===0);
            } else if(pinningMode==="corners"){
              pinned=((x===0&&y===0)||(x===cols-1&&y===0)||(x===0&&y===rows-1)||(x===cols-1&&y===rows-1));
            }
            clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned});
            grid[y][x]=clothPoints.length-1;
          }
        }
      }

      function createClothPoints_Draped(startX,fixedY,startZ){
        for(let rz=0;rz<rows;rz++){
          grid[rz]=[];
          for(let cx=0;cx<cols;cx++){
            let px=startX+cx*spacing, py=fixedY, pz=startZ+rz*spacing;
            clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned:false});
            grid[rz][cx]=clothPoints.length-1;
          }
        }
      }

      function createSubPointsAndConstraints(){
        // Exactly as before: horizontal midpoints, vertical midpoints, centers, then constraints
        // ...
        clothConstraints=[];

        // Structural constraints
        for(let y=0;y<rows;y++){
          for(let x=0;x<cols;x++){
            let idx=grid[y][x];
            if(x<cols-1){
              addConstraint(idx,grid[y][x+1], spacing*(stretchOn?stretchFactor:BASE_STRETCH));
            }
            if(y<rows-1){
              addConstraint(idx,grid[y+1][x], spacing*(stretchOn?stretchFactor:BASE_STRETCH));
            }
          }
        }
        // Bending, Shear, Subdivide as in your code
        // ...
      }

      function addConstraint(i,j,len){
        let a=min(i,j), b=max(i,j);
        for(let c of clothConstraints){
          if(c.p1===a && c.p2===b) return;
        }
        clothConstraints.push({p1:a,p2:b,length:len});
      }

      function draw(){
        background(30);
        if(doResetOrientation){
          // Move camera up so cylinder top is near top of screen
          camera(0,-200,(height/2)/tan(PI*30/180),  0,150,0,  0,1,0);
          doResetOrientation=false;
        }
        if(interactionMode==="rotate"){
          orbitControl();
        }
        if(simulationRunning){
          updateCloth();
        }

        if(simulationMode==="draped"){
          noStroke();
          fill("#222"); // Dark gray
          if(formMode==="sphere"){
            push();
            translate(sphereCenter.x, sphereCenter.y, sphereCenter.z);
            sphere(sphereRadius);
            pop();
          } else {
            // Cylinder top=150, bottom=450 => midpoint=300
            push();
            let midY=(cylinderTopY + cylinderBottomY)*0.5; // 300
            translate(0,midY,0);
            cylinder(cylRadius, cylHeight);
            pop();
          }
        }

        // If shadingOn => draw cloth shading
        if(shadingOn){
          let minY=Infinity, maxY=-Infinity;
          for(let y=0;y<rows;y++){
            for(let x=0;x<cols;x++){
              let pt=clothPoints[grid[y][x]];
              if(pt.y<minY) minY=pt.y;
              if(pt.y>maxY) maxY=pt.y;
            }
          }
          noStroke();
          for(let y=0;y<rows-1;y++){
            for(let x=0;x<cols-1;x++){
              let A=clothPoints[grid[y][x]];
              let B=clothPoints[grid[y][x+1]];
              let C=clothPoints[grid[y+1][x+1]];
              let D=clothPoints[grid[y+1][x]];
              let avgY=(A.y+B.y+C.y+D.y)*0.25;
              let bright=map(avgY,minY,maxY,220,80);
              fill(bright);
              beginShape();
              vertex(A.x,A.y,A.z);
              vertex(B.x,B.y,B.z);
              vertex(C.x,C.y,C.z);
              vertex(D.x,D.y,D.z);
              endShape(CLOSE);
            }
          }
        }

        // Draw cloth wireframe
        stroke(255); strokeWeight(2);
        for(let c of clothConstraints){
          let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
          line(p1.x,p1.y,p1.z, p2.x,p2.y,p2.z);
        }

        // Draw cloth points in red
        noStroke(); fill("#FF0000");
        for(let p of clothPoints){
          push();
          translate(p.x,p.y,p.z);
          sphere(2);
          pop();
        }
      }

      function updateCloth(){
        let freq=0.01;
        for(let p of clothPoints){
          if(!p.pinned){
            let vx=(p.x-p.oldx)*(dampingOn?damping:BASE_DAMPING);
            let vy=(p.y-p.oldy)*(dampingOn?damping:BASE_DAMPING);
            let vz=(p.z-p.oldz)*(dampingOn?damping:BASE_DAMPING);
            p.oldx=p.x; p.oldy=p.y; p.oldz=p.z;

            let sinVal=sin(frameCount*freq);
            let effWindX= windXOn? (windBuffer*windX*sinVal) : BASE_WINDX;
            let effWindY= windYOn? (windBuffer*windY*sinVal) : BASE_WINDY;
            let effWindZ= windZOn? (windBuffer*windZ*sinVal) : BASE_WINDZ;

            let effGrav= gravityOn? gravity : BASE_GRAVITY;
            let effWeight= weightOn? weight : BASE_WEIGHT;

            // Move cloth
            p.x+= vx + effWindX;
            p.y+= vy + effGrav*effWeight + effWindY; 
            p.z+= vz + effWindZ;
          }
        }
        let effIter= iterationsOn? iterations : BASE_ITERATIONS;
        for(let i=0;i<effIter;i++){
          for(let c of clothConstraints){
            let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
            let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
            let distVal=sqrt(dx*dx+dy*dy+dz*dz);
            let diff=(distVal-c.length)/distVal;
            let offsetX=dx*0.5*diff, offsetY=dy*0.5*diff, offsetZ=dz*0.5*diff;
            if(!p1.pinned){
              p1.x+=offsetX; p1.y+=offsetY; p1.z+=offsetZ;
            }
            if(!p2.pinned){
              p2.x-=offsetX; p2.y-=offsetY; p2.z-=offsetZ;
            }
          }
        }
        doSelfCollision();

        if(simulationMode==="draped"){
          if(formMode==="sphere") doSphereCollision();
          else if(formMode==="cylinder") doCylinderCollision();
          doCeilingClamp(); // clamp if cloth tries to go above y=150
        }
      }

      function doSelfCollision(){
        let threshold=spacing*0.5;
        for(let i=0;i<clothPoints.length;i++){
          for(let j=i+1;j<clothPoints.length;j++){
            let p1=clothPoints[i], p2=clothPoints[j];
            let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
            let d=sqrt(dx*dx+dy*dy+dz*dz);
            if(d<threshold && d>0){
              let overlap=threshold-d;
              let angle=atan2(dy,dx);
              if(!p1.pinned && !p2.pinned){
                p1.x-=cos(angle)*overlap*0.5;
                p1.y-=sin(angle)*overlap*0.5;
                p2.x+=cos(angle)*overlap*0.5;
                p2.y+=sin(angle)*overlap*0.5;
              } else if(!p1.pinned && p2.pinned){
                p1.x-=cos(angle)*overlap;
                p1.y-=sin(angle)*overlap;
              } else if(p1.pinned && !p2.pinned){
                p2.x+=cos(angle)*overlap;
                p2.y+=sin(angle)*overlap;
              }
            }
          }
        }
      }

      function doSphereCollision(){
        const friction=0.5;
        for(let p of clothPoints){
          if(!p.pinned){
            let dx=p.x-sphereCenter.x, dy=p.y-sphereCenter.y, dz=p.z-sphereCenter.z;
            let distVal=sqrt(dx*dx+dy*dy+dz*dz);
            if(distVal<sphereRadius){
              let overlap=sphereRadius-distVal;
              let nx=dx/distVal, ny=dy/distVal, nz=dz/distVal;
              p.x+=nx*overlap; p.y+=ny*overlap; p.z+=nz*overlap;
              p.oldx=p.x-friction*(p.x-p.oldx);
              p.oldy=p.y-friction*(p.y-p.oldy);
              p.oldz=p.z-friction*(p.z-p.oldz);
            }
          }
        }
      }

      function doCylinderCollision(){
        // Cylinder from y=150 (top) to y=450 (bottom)
        const friction=0.5;
        for(let p of clothPoints){
          if(!p.pinned){
            if(p.y>=cylinderTopY && p.y<=cylinderBottomY){
              let r=sqrt(p.x*p.x + p.z*p.z);
              if(r<cylRadius){
                let overlap=cylRadius-r;
                let nx=p.x/r, nz=p.z/r;
                p.x+=nx*overlap;
                p.z+=nz*overlap;
                p.oldx=p.x-friction*(p.x-p.oldx);
                p.oldz=p.z-friction*(p.z-p.oldz);
              }
            }
          }
        }
      }

      function doCeilingClamp(){
        // If cloth tries to go above y=150, clamp it
        const friction=0.5;
        for(let p of clothPoints){
          if(!p.pinned && p.y< cylinderTopY){
            p.y= cylinderTopY; // clamp to 150
            // Minor friction on oldy
            p.oldy= p.y + friction*(p.oldy - p.y);
          }
        }
      }

      function mousePressed(){
        if(interactionMode==="drag"){
          let closest=null, closestDist=10;
          for(let i=0;i<clothPoints.length;i++){
            let p=clothPoints[i];
            let sx=modelX(p.x,p.y,p.z), sy=modelY(p.x,p.y,p.z);
            let d=dist(mouseX,mouseY,sx,sy);
            if(d<closestDist){closestDist=d;closest=i;}
          }
          if(closest!==null){
            dragPointIndex=closest;
            dragPlaneZ=clothPoints[closest].z;
          }
        }
      }

      function mouseDragged(){
        if(interactionMode==="drag" && dragPointIndex!==null){
          let newPos=unproject(mouseX,mouseY,dragPlaneZ);
          let p=clothPoints[dragPointIndex];
          p.x=newPos.x; p.y=newPos.y;
          p.oldx=newPos.x; p.oldy=newPos.y;
        }
      }

      function mouseReleased(){
        dragPointIndex=null;
      }

      function unproject(mx,my,fz){
        let d=(height/2)/tan(PI*30/180);
        let nx=mx-width/2, ny=my-height/2;
        let factor=(d+fz)/d;
        return createVector(nx*factor, ny*factor, fz);
      }

      function windowResized(){
        resizeCanvas(windowWidth-280, windowHeight);
      }
    </script>
  </body>
</html>
