          for(let x=0; x<cols; x++){
            let idx1 = grid[y][x], idx2 = grid[y+2][x];
            addConstraint(idx1, idx2, spacing*2*(bendingOn?bendingFactor:BASE_BENDING));
          }
        }
        // Shear
        for(let y=0; y<rows-1; y++){
          for(let x=0; x<cols-1; x++){
            let iA = grid[y][x], iB = grid[y][x+1];
            let iC = grid[y+1][x], iD = grid[y+1][x+1];
            addConstraint(iA, iD, Math.sqrt(2)*spacing*(shearOn?shearFactor:BASE_SHEAR));
            addConstraint(iB, iC, Math.sqrt(2)*spacing*(shearOn?shearFactor:BASE_SHEAR));
          }
        }
        // Subdivide each cell => 8 triangles
        function cDist(i1, i2){
          let p1 = clothPoints[i1], p2 = clothPoints[i2];
          let dx = p2.x - p1.x, dy = p2.y - p1.y, dz = p2.z - p1.z;
          return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        function cAdd(i1, i2){ addConstraint(i1, i2, cDist(i1, i2)); }

        for(let y=0; y<rows-1; y++){
          for(let x=0; x<cols-1; x++){
            let A = grid[y][x], B = grid[y][x+1];
            let C = grid[y+1][x], D = grid[y+1][x+1];
            let E = horizontal[y][x], F = horizontal[y+1][x];
            let G = vertical[y][x],   H = vertical[y][x+1];
            let I = centers[y][x];
            // 8 triangles
            cAdd(A, E); cAdd(E, I); cAdd(I, A);
            cAdd(A, G); cAdd(G, I); cAdd(I, A);
            cAdd(B, E); cAdd(E, I); cAdd(I, B);
            cAdd(B, H); cAdd(H, I); cAdd(I, B);
            cAdd(C, G); cAdd(G, I); cAdd(I, C);
            cAdd(C, F); cAdd(F, I); cAdd(I, C);
            cAdd(D, H); cAdd(H, I); cAdd(I, D);
            cAdd(D, F); cAdd(F, I); cAdd(I, D);
          }
        }
      }

      function addConstraint(i, j, len){
        let a = Math.min(i, j), b = Math.max(i, j);
        for(let c of clothConstraints){
          if(c.p1 === a && c.p2 === b) return;
        }
        clothConstraints.push({p1:a, p2:b, length:len});
      }

      function draw(){
        background(30);
        if(doResetOrientation){
          camera(0, -200, (height/2)/tan(PI*30/180), 0, 100, 0, 0, 1, 0);
          doResetOrientation = false;
        }
        if(interactionMode==="rotate") orbitControl();
        if(simulationRunning) updateCloth();

        // Draw shape only if Draped
        if(simulationMode==="draped"){
          noStroke(); fill("#222");
          if(formMode==="sphere"){
            push();
            translate(sphereCenter.x, sphereCenter.y, sphereCenter.z);
            sphere(sphereRadius);
            pop();
          } else {
            push();
            let midY = (cylinderTopY + cylinderBottomY)/2;
            translate(0, midY, 0);
            cylinder(cylRadius, cylHeight);
            pop();
          }
        }

        // If shadingOn => fill cloth
        if(shadingOn){
          let minY = Infinity, maxY = -Infinity;
          for(let y=0; y<rows; y++){
            for(let x=0; x<cols; x++){
              let pt = clothPoints[grid[y][x]];
              if(pt.y < minY) minY = pt.y;
              if(pt.y > maxY) maxY = pt.y;
            }
          }
          noStroke();
          for(let y=0; y<rows-1; y++){
            for(let x=0; x<cols-1; x++){
              let A = clothPoints[grid[y][x]];
              let B = clothPoints[grid[y][x+1]];
              let C = clothPoints[grid[y+1][x+1]];
              let D = clothPoints[grid[y+1][x]];
              let avgY = (A.y + B.y + C.y + D.y)*0.25;
              let bright = map(avgY, minY, maxY, 220, 80);
              fill(bright);
              beginShape();
              vertex(A.x, A.y, A.z);
              vertex(B.x, B.y, B.z);
              vertex(C.x, C.y, C.z);
              vertex(D.x, D.y, D.z);
              endShape(CLOSE);
            }
          }
        }

        // Draw wireframe constraints
        stroke(255); strokeWeight(2);
        for(let c of clothConstraints){
          let p1 = clothPoints[c.p1], p2 = clothPoints[c.p2];
          line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        }

        // Draw points
        noStroke(); fill("#FF0000");
        for(let p of clothPoints){
          push();
          translate(p.x, p.y, p.z);
          sphere(2);
          pop();
        }
      }

      function updateCloth(){
        let freq = 0.01;
        // 1) Update positions via velocity, wind, gravity
        for(let p of clothPoints){
          if(!p.pinned){
            let vx = (p.x - p.oldx) * (dampingOn ? damping : BASE_DAMPING);
            let vy = (p.y - p.oldy) * (dampingOn ? damping : BASE_DAMPING);
            let vz = (p.z - p.oldz) * (dampingOn ? damping : BASE_DAMPING);

            p.oldx = p.x;
            p.oldy = p.y;
            p.oldz = p.z;

            let sinVal = sin(frameCount * freq);
            let effWindX = windXOn ? (windBuffer * windX * sinVal) : BASE_WINDX;
            let effWindY = windYOn ? (windBuffer * windY * sinVal) : BASE_WINDY;
            let effWindZ = windZOn ? (windBuffer * windZ * sinVal) : BASE_WINDZ;

            let effGrav = gravityOn ? gravity : BASE_GRAVITY;
            let effWeight = weightOn ? weight : BASE_WEIGHT;

            p.x += vx + effWindX;
            p.y += vy + effGrav * effWeight + effWindY;
            p.z += vz + effWindZ;
          }
        }

        // 2) Constraint iterations
        let effIter = (iterationsOn ? iterations : BASE_ITERATIONS);
        for(let i = 0; i < effIter; i++){
          // --- Relax constraints ---
          for(let c of clothConstraints){
            let p1 = clothPoints[c.p1], p2 = clothPoints[c.p2];
            let dx = p2.x - p1.x, dy = p2.y - p1.y, dz = p2.z - p1.z;
            let distVal = sqrt(dx*dx + dy*dy + dz*dz);
            let diff = (distVal - c.length)/distVal;
            let offsetX = dx*0.5*diff, offsetY = dy*0.5*diff, offsetZ = dz*0.5*diff;
            if(!p1.pinned){
              p1.x += offsetX;
              p1.y += offsetY;
              p1.z += offsetZ;
            }
            if(!p2.pinned){
              p2.x -= offsetX;
              p2.y -= offsetY;
              p2.z -= offsetZ;
            }
          }

          // --- Only do shape collision if "draped" mode ---
          if(simulationMode === "draped"){
            if(formMode === "sphere") doSphereCollision();
            else if(formMode === "cylinder") doCylinderCollision();
          }
        }

        // 3) Self-collision (1 pass at the end)
        doSelfCollision();

        // 4) If plane mode => simple floor clamp at y=0
        if(simulationMode === "plane"){
          doPlaneFloorClamp(); 
        }
        // If draped => final shape collision + clamps
        else {
          if(formMode === "sphere") doSphereCollision();
          else if(formMode === "cylinder") doCylinderCollision();
          doCeilingClamp();
          doFloorClamp();
        }
      }

      /* =========================
         EXTRA COLLISION/CLAMP LOGIC
      ==========================*/
      function doPlaneFloorClamp(){
        // For plane mode, clamp the cloth so it won't go below y=0
        const friction = 0.5;
        let floorY = 0;
        for(let p of clothPoints){
          if(!p.pinned && p.y > floorY){
            p.y = floorY;
            p.oldy = p.y - friction*(p.y - p.oldy);
          }
        }
      }

      function doSelfCollision(){
        let threshold = spacing*0.5;
        for(let i=0; i<clothPoints.length; i++){
          for(let j=i+1; j<clothPoints.length; j++){
            let p1 = clothPoints[i], p2 = clothPoints[j];
            let dx = p2.x - p1.x, dy = p2.y - p1.y, dz = p2.z - p1.z;
            let d = sqrt(dx*dx + dy*dy + dz*dz);
            if(d < threshold && d>0){
              let overlap = threshold - d;
              let angle = atan2(dy, dx);
              if(!p1.pinned && !p2.pinned){
                p1.x -= cos(angle)*overlap*0.5;
                p1.y -= sin(angle)*overlap*0.5;
                p2.x += cos(angle)*overlap*0.5;
                p2.y += sin(angle)*overlap*0.5;
              } else if(!p1.pinned && p2.pinned){
                p1.x -= cos(angle)*overlap;
                p1.y -= sin(angle)*overlap;
              } else if(p1.pinned && !p2.pinned){
                p2.x += cos(angle)*overlap;
                p2.y += sin(angle)*overlap;
              }
            }
          }
        }
      }

      function doSphereCollision(){
        // Sphere: bottom=0, top=200 => center=100, radius=100
        const friction = 0.5;
        for(let p of clothPoints){
          if(!p.pinned){
            let dx = p.x - sphereCenter.x;
            let dy = p.y - sphereCenter.y;
            let dz = p.z - sphereCenter.z;
            let distVal = sqrt(dx*dx + dy*dy + dz*dz);
            if(distVal < sphereRadius){
              let overlap = sphereRadius - distVal;
              let nx = dx/distVal, ny = dy/distVal, nz = dz/distVal;
              p.x += nx*overlap;
              p.y += ny*overlap;
              p.z += nz*overlap;
              p.oldx = p.x - friction*(p.x - p.oldx);
              p.oldy = p.y - friction*(p.y - p.oldy);
              p.oldz = p.z - friction*(p.z - p.oldz);
            }
          }
        }
      }

      function doCylinderCollision(){
        // Cylinder: top=0, bottom=300 => if 0<=p.y<=300 => check radial
        const friction = 0.5;
        for(let p of clothPoints){
          if(!p.pinned && p.y >= cylinderTopY && p.y <= cylinderBottomY){
            let r = sqrt(p.x*p.x + p.z*p.z);
            if(r < cylRadius){
              let overlap = cylRadius - r;
              let nx = p.x/r, nz = p.z/r;
              p.x += nx*overlap;
              p.z += nz*overlap;
              p.oldx = p.x - friction*(p.x - p.oldx);
              p.oldz = p.z - friction*(p.z - p.oldz);
            }
          }
        }
      }

      function doCeilingClamp(){
        // For sphere pinned at y=0, for cylinder pinned at y=0
        const friction = 0.5;
        let clampY = (formMode==="sphere"? 0 : cylinderTopY);
        for(let p of clothPoints){
          if(!p.pinned && p.y < clampY){
            p.y = clampY;
            p.oldy = p.y + friction*(p.oldy - p.y);
          }
        }
      }

      function doFloorClamp(){
        // For sphere => top=200 => if p.y>200 clamp
        // For cylinder => bottom=300 => if p.y>300 clamp
        const friction = 0.5;
        let floorY = (formMode==="sphere"? 200 : cylinderBottomY);
        for(let p of clothPoints){
          if(!p.pinned && p.y>floorY){
            p.y = floorY;
            p.oldy = p.y - friction*(p.y - p.oldy);
          }
        }
      }

      // 3D Drag with partial "lerp" for smoother motion
      function mousePressed(){
        if(interactionMode==="drag"){
          let closest = null, closestDist = 10;
          for(let i=0; i<clothPoints.length; i++){
            let p = clothPoints[i];
            let sx = modelX(p.x, p.y, p.z), sy = modelY(p.x, p.y, p.z);
            let d = dist(mouseX, mouseY, sx, sy);
            if(d<closestDist){
              closestDist=d;
              closest=i;
            }
          }
          if(closest!==null){
            dragPointIndex = closest;
            dragPlaneZ = clothPoints[closest].z;
          }
        }
      }

      function mouseDragged(){
        if(interactionMode==="drag" && dragPointIndex!==null){
          let p = clothPoints[dragPointIndex];
          // Use the point's current z to unproject
          let newPos = unproject(mouseX, mouseY, p.z);
          // Lerp for smoother drag
          p.x = lerp(p.x, newPos.x, dragStrength);
          p.y = lerp(p.y, newPos.y, dragStrength);
          // Keep old coords updated so it doesn't snap back
          p.oldx = p.x;
          p.oldy = p.y;
        }
      }

      function mouseReleased(){
        dragPointIndex = null;
      }

      function unproject(mx,my,fz){
        let d = (height/2)/tan(PI*30/180);
        let nx = mx - width/2, ny = my - height/2;
        let factor = (d + fz)/d;
        return createVector(nx*factor, ny*factor, fz);
      }

      function windowResized(){
        resizeCanvas(windowWidth - 280, windowHeight);
      }
    </script>
  </body>
</html>
