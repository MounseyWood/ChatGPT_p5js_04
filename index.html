<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Cloth Simulation â€“ Plane & Draped (Sphere or Cylinder)</title>
    <!-- p5.js library -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
    <style>
      /* Global Layout & Colors */
      body, html {
        margin: 0;
        padding: 0;
        background: #111;
        color: #fff;
        font-family: sans-serif;
        height: 100%;
      }
      #uiPanel {
        position: absolute;
        top: 0;
        left: 0;
        width: 280px;
        height: 100%;
        background: #222;
        box-shadow: 2px 0 8px rgba(0,0,0,0.5);
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
      }
      #canvasContainer {
        position: absolute;
        top: 0;
        left: 280px;
        width: calc(100% - 280px);
        height: 100%;
        overflow: hidden;
      }
      h2 {
        margin-top: 0;
      }
      p, label {
        font-size: 14px;
        line-height: 1.4em;
        margin-bottom: 8px;
      }
      /* Parameter containers */
      .parameter {
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid #333;
      }
      .paramHeader {
        margin-bottom: 4px;
        font-weight: bold;
      }
      .paramRadio {
        display: flex;
        gap: 8px;
        margin-bottom: 4px;
      }
      /* Use Dodger Blue (#1e90ff) for radios and sliders */
      .paramRadio input[type="radio"] {
        accent-color: #1e90ff;
      }
      input[type="range"] {
        accent-color: #1e90ff;
      }
      .paramContainer {
        margin-top: 4px;
        display: none; /* Hidden until "on" is selected */
      }
      .paramDesc {
        font-size: 12px;
        color: #aaa;
        margin-top: 4px;
      }
      /* Sticky bottom buttons */
      .bottomButtons {
        position: sticky;
        bottom: 20px;
        width: 100%;
      }
      button {
        width: 100%;
        padding: 8px 12px;
        background: #555;
        color: #fff;
        border: none;
        cursor: pointer;
        margin-bottom: 10px;
      }
      button:hover {
        background: #666;
      }
    </style>
  </head>
  <body>
    <!-- UI Panel -->
    <div id="uiPanel">
      <h2>3D Cloth Simulation</h2>
      <p>
        Two main simulation modes: <strong>Plane</strong> or <strong>Draped</strong>.<br>
        In Draped mode, choose <strong>Sphere</strong> or <strong>Cylinder</strong> (dark gray) as the form.
      </p>

      <!-- Simulation Mode -->
      <div class="parameter">
        <div class="paramHeader">Simulation Mode:</div>
        <div id="simModeRadio"></div>
        <div class="paramDesc">
          <strong>Plane</strong>: pinned cloth in free space.<br>
          <strong>Draped</strong>: cloth drapes over a form (sphere or cylinder).
        </div>
      </div>

      <!-- Form Mode (only relevant in Draped mode) -->
      <div class="parameter" id="formModeParam">
        <div class="paramHeader">Form Mode:</div>
        <div id="formModeRadio"></div>
        <div class="paramDesc">
          Choose <strong>Sphere</strong> or <strong>Cylinder</strong> (dark gray) as the underlying form.
        </div>
      </div>

      <!-- Interaction Mode -->
      <div class="parameter">
        <div class="paramHeader">Interaction Mode:</div>
        <div id="interactionRadioGroup"></div>
        <div class="paramDesc">
          "Rotate" = move the camera; "Drag" = pick cloth points.<br>
          (Use "Reset Orientation" first for best dragging.)
        </div>
      </div>

      <!-- Pinning Mode (only for Plane mode) -->
      <div class="parameter">
        <div class="paramHeader">Pinning Mode:</div>
        <div id="pinningRadio"></div>
        <div class="paramDesc">Only relevant in Plane mode.</div>
      </div>

      <!-- Damping -->
      <div class="parameter">
        <div class="paramHeader">Damping: <span id="dampingVal"></span></div>
        <div class="paramRadio" id="dampingRadioGroup"></div>
        <div id="dampingContainer" class="paramContainer">
          <div id="dampingSlider"></div>
          <div class="paramDesc">Controls energy loss (Off = 1.0).</div>
        </div>
      </div>

      <!-- Iterations -->
      <div class="parameter">
        <div class="paramHeader">Iterations: <span id="iterationsVal"></span></div>
        <div class="paramRadio" id="iterationsRadioGroup"></div>
        <div id="iterationsContainer" class="paramContainer">
          <div id="iterationsSlider"></div>
          <div class="paramDesc">Constraint relaxations per frame (Off = 1).</div>
        </div>
      </div>

      <!-- Stretch -->
      <div class="parameter">
        <div class="paramHeader">Stretch: <span id="stretchVal"></span></div>
        <div class="paramRadio" id="stretchRadioGroup"></div>
        <div id="stretchContainer" class="paramContainer">
          <div id="stretchSlider"></div>
          <div class="paramDesc">Affects cloth extension (Off = 1.0).</div>
        </div>
      </div>

      <!-- Shear -->
      <div class="parameter">
        <div class="paramHeader">Shear: <span id="shearVal"></span></div>
        <div class="paramRadio" id="shearRadioGroup"></div>
        <div id="shearContainer" class="paramContainer">
          <div id="shearSlider"></div>
          <div class="paramDesc">Resists diagonal distortion (Off = 1.0).</div>
        </div>
      </div>

      <!-- Bending -->
      <div class="parameter">
        <div class="paramHeader">Bending: <span id="bendingVal"></span></div>
        <div class="paramRadio" id="bendingRadioGroup"></div>
        <div id="bendingContainer" class="paramContainer">
          <div id="bendingSlider"></div>
          <div class="paramDesc">Resistance to sharp folds (Off = 1.0).</div>
        </div>
      </div>

      <!-- Weight -->
      <div class="parameter">
        <div class="paramHeader">Weight: <span id="weightVal"></span></div>
        <div class="paramRadio" id="weightRadioGroup"></div>
        <div id="weightContainer" class="paramContainer">
          <div id="weightSlider"></div>
          <div class="paramDesc">Downward pull (Off = 1.0).</div>
        </div>
      </div>

      <!-- Wind X -->
      <div class="parameter">
        <div class="paramHeader">Wind X: <span id="windXVal"></span></div>
        <div class="paramRadio" id="windXRadioGroup"></div>
        <div id="windXContainer" class="paramContainer">
          <div id="windXSlider"></div>
          <div class="paramDesc">Wind force along X (Off = 0).</div>
        </div>
      </div>

      <!-- Wind Y -->
      <div class="parameter">
        <div class="paramHeader">Wind Y: <span id="windYVal"></span></div>
        <div class="paramRadio" id="windYRadioGroup"></div>
        <div id="windYContainer" class="paramContainer">
          <div id="windYSlider"></div>
          <div class="paramDesc">Wind force along Y (Off = 0).</div>
        </div>
      </div>

      <!-- Wind Z -->
      <div class="parameter">
        <div class="paramHeader">Wind Z: <span id="windZVal"></span></div>
        <div class="paramRadio" id="windZRadioGroup"></div>
        <div id="windZContainer" class="paramContainer">
          <div id="windZSlider"></div>
          <div class="paramDesc">Wind force along Z (Off = 0).</div>
        </div>
      </div>

      <!-- Wind Buffer -->
      <div class="parameter">
        <div class="paramHeader">Wind Buffer: <span id="windBufVal"></span></div>
        <div class="paramRadio" id="windBufRadioGroup"></div>
        <div id="windBufContainer" class="paramContainer">
          <div id="windBufSlider"></div>
          <div class="paramDesc">Scales overall wind amplitude (Off = 1.0).</div>
        </div>
      </div>

      <!-- Gravity -->
      <div class="parameter">
        <div class="paramHeader">Gravity: <span id="gravityVal"></span></div>
        <div class="paramRadio" id="gravityRadioGroup"></div>
        <div id="gravityContainer" class="paramContainer">
          <div id="gravitySlider"></div>
          <div class="paramDesc">Downward acceleration (Off = 0).</div>
        </div>
      </div>

      <!-- Shading Mode -->
      <div class="parameter">
        <div class="paramHeader">Shading Mode:</div>
        <div class="paramRadio" id="shadingRadioGroup"></div>
        <div class="paramDesc">Gray-scale fill based on vertical position.</div>
      </div>

      <div class="bottomButtons">
        <button id="playPauseBtn">Pause Simulation</button>
        <button id="resetOrientationBtn">Reset Orientation</button>
        <button id="resetBtn">Reset Cloth</button>
      </div>
    </div>

    <div id="canvasContainer"></div>

    <script>
      /* ----------------------
       * CLOTH / SHAPES SETUP
       * ---------------------- */

      let cols = 20, rows = 20, spacing = 20;
      let clothPoints = [], clothConstraints = [];
      let grid = [], horizontal = [], vertical = [], centers = [];

      // Sphere for Draped mode
      let sphereCenter = { x: 0, y: 0, z: 0 };
      let sphereRadius = 100;

      // Cylinder for Draped mode: floor is y=150
      // bottom = 150, top = 450, height=300
      let floorY = 150;
      let cylRadius = 100;
      let cylHeight = 300;
      let cylinderBottomY = floorY;            // 150
      let cylinderTopY = cylinderBottomY + cylHeight; // 450

      // Simulation parameters
      let damping = 0.98;
      let iterations = 5;
      let stretchFactor = 1.0;
      let shearFactor = 1.0;
      let bendingFactor = 1.0;
      let weight = 1.0;
      let windX = 0.2, windY = 0, windZ = 0.1;
      let windBuffer = 1.0;
      let gravity = 0.4;

      // Baseline "off" values
      const BASE_DAMPING = 1.0;
      const BASE_ITERATIONS = 1;
      const BASE_STRETCH = 1.0;
      const BASE_SHEAR = 1.0;
      const BASE_BENDING = 1.0;
      const BASE_WEIGHT = 1.0;
      const BASE_WINDX = 0.0, BASE_WINDY = 0.0, BASE_WINDZ = 0.0;
      const BASE_WINDBUFFER = 1.0;
      const BASE_GRAVITY = 0.0;

      // Flags for toggles
      let dampingOn = false;
      let iterationsOn = false;
      let stretchOn = false;
      let shearOn = false;
      let bendingOn = false;
      let weightOn = false;
      let windXOn = false;
      let windYOn = false;
      let windZOn = false;
      let windBufOn = false;
      let gravityOn = false;
      let shadingOn = false;

      // Modes
      let pinningMode = "top";   // Only for Plane
      let interactionMode = "rotate";
      let simulationMode = "plane"; // "plane" or "draped"
      let formMode = "sphere";      // "sphere" or "cylinder"

      // Cloth positioning
      let clothShiftX = -40;

      // Orientation / play/pause
      let doResetOrientation = false;
      let simulationRunning = true;

      // Dragging
      let dragPointIndex = null;
      let dragPlaneZ = 0;

      function setup() {
        let cnv = createCanvas(windowWidth - 280, windowHeight, WEBGL);
        cnv.parent("canvasContainer");
        cnv.style("display","block");
        createUI();
        setupCloth();
      }

      function createUI() {
        // Buttons
        select("#resetBtn").mousePressed(setupCloth);
        select("#resetOrientationBtn").mousePressed(() => { doResetOrientation = true; });
        const playPauseBtn = select("#playPauseBtn");
        playPauseBtn.mousePressed(() => {
          simulationRunning = !simulationRunning;
          playPauseBtn.html(simulationRunning ? "Pause Simulation" : "Play Simulation");
        });

        // Simulation Mode
        let simModeRadio = createRadio();
        simModeRadio.option("plane","Plane");
        simModeRadio.option("draped","Draped");
        simModeRadio.selected("plane");
        simModeRadio.parent("simModeRadio");
        simModeRadio.changed(() => {
          simulationMode = simModeRadio.value();
          setupCloth();
        });

        // Form Mode
        let formModeRadio = createRadio();
        formModeRadio.option("sphere","Sphere");
        formModeRadio.option("cylinder","Cylinder");
        formModeRadio.selected("sphere");
        formModeRadio.parent("formModeRadio");
        formModeRadio.changed(() => {
          formMode = formModeRadio.value();
          if(simulationMode==="draped") setupCloth();
        });

        // Interaction
        let interactionRadio = createRadio();
        interactionRadio.option("rotate","Rotate");
        interactionRadio.option("drag","Drag");
        interactionRadio.selected("rotate");
        interactionRadio.parent("interactionRadioGroup");
        interactionRadio.changed(() => {
          interactionMode = interactionRadio.value();
        });

        // Pinning Mode
        let pinRadio = createRadio();
        pinRadio.option("top","Top Pinned");
        pinRadio.option("corners","Corner Pinned");
        pinRadio.selected("top");
        pinRadio.parent("pinningRadio");
        pinRadio.changed(() => {
          pinningMode = pinRadio.value();
          if(simulationMode==="plane") setupCloth();
        });

        // Helper to attach param toggles
        function attachParamRadio(parentId, setFlag, containerId) {
          let r = createRadio();
          r.option("off","Off");
          r.option("on","On");
          r.parent(parentId);
          r.selected("off");
          r.changed(() => {
            let val = r.value();
            let on = (val==="on");
            setFlag(on);
            if(containerId){
              if(on) select("#"+containerId).style("display","block");
              else select("#"+containerId).style("display","none");
            }
          });
        }

        attachParamRadio("dampingRadioGroup",(on)=>{dampingOn=on;},"dampingContainer");
        attachParamRadio("iterationsRadioGroup",(on)=>{iterationsOn=on;},"iterationsContainer");
        attachParamRadio("stretchRadioGroup",(on)=>{stretchOn=on;},"stretchContainer");
        attachParamRadio("shearRadioGroup",(on)=>{shearOn=on;},"shearContainer");
        attachParamRadio("bendingRadioGroup",(on)=>{bendingOn=on;},"bendingContainer");
        attachParamRadio("weightRadioGroup",(on)=>{weightOn=on;},"weightContainer");
        attachParamRadio("windXRadioGroup",(on)=>{windXOn=on;},"windXContainer");
        attachParamRadio("windYRadioGroup",(on)=>{windYOn=on;},"windYContainer");
        attachParamRadio("windZRadioGroup",(on)=>{windZOn=on;},"windZContainer");
        attachParamRadio("windBufRadioGroup",(on)=>{windBufOn=on;},"windBufContainer");
        attachParamRadio("gravityRadioGroup",(on)=>{gravityOn=on;},"gravityContainer");
        attachParamRadio("shadingRadioGroup",(on)=>{shadingOn=on;},null);

        // Sliders
        function createSliderAndLabel(divId,callback,min,max,val,step){
          const slider=createSlider(min,max,val,step);
          slider.parent(divId);
          slider.input(()=>{callback(slider.value());});
          callback(slider.value());
        }
        createSliderAndLabel("dampingSlider",(v)=>{ damping=v; select("#dampingVal").html(nf(v,1,2)); },0.90,1.0,0.98,0.01);
        createSliderAndLabel("iterationsSlider",(v)=>{ iterations=v; select("#iterationsVal").html(v); },1,10,5,1);
        createSliderAndLabel("stretchSlider",(v)=>{ stretchFactor=v; select("#stretchVal").html(nf(v,1,2)); },0.8,1.2,1.0,0.01);
        createSliderAndLabel("shearSlider",(v)=>{ shearFactor=v; select("#shearVal").html(nf(v,1,2)); },0.8,1.2,1.0,0.01);
        createSliderAndLabel("bendingSlider",(v)=>{ bendingFactor=v; select("#bendingVal").html(nf(v,1,2)); },0.8,1.2,1.0,0.01);
        createSliderAndLabel("weightSlider",(v)=>{ weight=v; select("#weightVal").html(nf(v,1,2)); },0.5,2.0,1.0,0.1);
        createSliderAndLabel("windXSlider",(v)=>{ windX=v; select("#windXVal").html(nf(v,1,2)); },-1,1,0.2,0.01);
        createSliderAndLabel("windYSlider",(v)=>{ windY=v; select("#windYVal").html(nf(v,1,2)); },-1,1,0,0.01);
        createSliderAndLabel("windZSlider",(v)=>{ windZ=v; select("#windZVal").html(nf(v,1,2)); },-1,1,0.1,0.01);
        createSliderAndLabel("windBufSlider",(v)=>{ windBuffer=v; select("#windBufVal").html(nf(v,1,2)); },0,2,1.0,0.01);
        createSliderAndLabel("gravitySlider",(v)=>{ gravity=v; select("#gravityVal").html(nf(v,1,2)); },0,1,0.4,0.01);
      }

      function setupCloth() {
        clothPoints = [];
        clothConstraints = [];
        grid = [];
        horizontal = [];
        vertical = [];
        centers = [];

        let clothWidth = (cols - 1)*spacing;
        let clothHeight= (rows - 1)*spacing;

        if(simulationMode==="plane"){
          let startX= -clothWidth/2 + clothShiftX;
          let startY= -clothHeight/2;
          createClothPoints_Plane(startX,startY,0);
        } else {
          // Draped mode
          if(formMode==="sphere"){
            // Sphere
            sphereCenter={x:0,y:0,z:0};
            sphereRadius=100;
            let startY= -sphereRadius; // cloth at y=-100
            createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);

            let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
            let centerIdx=grid[midRow][midCol];
            clothPoints[centerIdx].pinned=true;
            clothPoints[centerIdx].x= sphereCenter.x;
            clothPoints[centerIdx].y= sphereCenter.y - sphereRadius; // y=-100
            clothPoints[centerIdx].z= sphereCenter.z;
            clothPoints[centerIdx].oldx= sphereCenter.x;
            clothPoints[centerIdx].oldy= sphereCenter.y - sphereRadius;
            clothPoints[centerIdx].oldz= sphereCenter.z;
          } else {
            // Cylinder on floor y=150 => top=450
            cylinderBottomY= floorY; // 150
            cylHeight= 300;
            cylinderTopY= cylinderBottomY + cylHeight; // 450
            let startY= cylinderTopY; // 450
            createClothPoints_Draped(-clothWidth/2,startY,-clothHeight/2);

            let midRow=Math.floor(rows/2), midCol=Math.floor(cols/2);
            let centerIdx= grid[midRow][midCol];
            clothPoints[centerIdx].pinned= true;
            clothPoints[centerIdx].x=0;
            clothPoints[centerIdx].y= cylinderTopY; // 450
            clothPoints[centerIdx].z=0;
            clothPoints[centerIdx].oldx=0;
            clothPoints[centerIdx].oldy= cylinderTopY;
            clothPoints[centerIdx].oldz=0;
          }
        }
        createSubPointsAndConstraints();
      }

      function createClothPoints_Plane(startX,startY,startZ){
        for(let y=0;y<rows;y++){
          grid[y]=[];
          for(let x=0;x<cols;x++){
            let px=startX+x*spacing;
            let py=startY+y*spacing;
            let pz=startZ;
            let pinned=false;
            if(pinningMode==="top"){
              pinned=(y===0);
            } else if(pinningMode==="corners"){
              pinned=((x===0&&y===0)||(x===cols-1&&y===0)||(x===0&&y===rows-1)||(x===cols-1&&y===rows-1));
            }
            clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned});
            grid[y][x]=clothPoints.length-1;
          }
        }
      }

      function createClothPoints_Draped(startX,fixedY,startZ){
        for(let rz=0;rz<rows;rz++){
          grid[rz]=[];
          for(let cx=0;cx<cols;cx++){
            let px=startX+cx*spacing;
            let py=fixedY;
            let pz=startZ+rz*spacing;
            clothPoints.push({x:px,y:py,z:pz,oldx:px,oldy:py,oldz:pz,pinned:false});
            grid[rz][cx]=clothPoints.length-1;
          }
        }
      }

      function createSubPointsAndConstraints(){
        horizontal=[];
        for(let y=0;y<rows;y++){
          horizontal[y]=[];
          for(let x=0;x<cols-1;x++){
            let idxA=grid[y][x], idxB=grid[y][x+1];
            let A=clothPoints[idxA], B=clothPoints[idxB];
            let mx=(A.x+B.x)*0.5, my=(A.y+B.y)*0.5, mz=(A.z+B.z)*0.5;
            clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
            horizontal[y][x]=clothPoints.length-1;
          }
        }
        vertical=[];
        for(let y=0;y<rows-1;y++){
          vertical[y]=[];
          for(let x=0;x<cols;x++){
            let idxA=grid[y][x], idxB=grid[y+1][x];
            let A=clothPoints[idxA], B=clothPoints[idxB];
            let mx=(A.x+B.x)*0.5, my=(A.y+B.y)*0.5, mz=(A.z+B.z)*0.5;
            clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
            vertical[y][x]=clothPoints.length-1;
          }
        }
        centers=[];
        for(let y=0;y<rows-1;y++){
          centers[y]=[];
          for(let x=0;x<cols-1;x++){
            let idxA=grid[y][x], idxB=grid[y][x+1];
            let idxC=grid[y+1][x], idxD=grid[y+1][x+1];
            let A=clothPoints[idxA], B=clothPoints[idxB];
            let C=clothPoints[idxC], D=clothPoints[idxD];
            let mx=(A.x+B.x+C.x+D.x)*0.25;
            let my=(A.y+B.y+C.y+D.y)*0.25;
            let mz=(A.z+B.z+C.z+D.z)*0.25;
            clothPoints.push({x:mx,y:my,z:mz,oldx:mx,oldy:my,oldz:mz,pinned:false});
            centers[y][x]=clothPoints.length-1;
          }
        }
        createConstraints();
      }

      function createConstraints(){
        clothConstraints=[];
        // Structural constraints (Stretch)
        for(let y=0;y<rows;y++){
          for(let x=0;x<cols;x++){
            let idx=grid[y][x];
            // Horizontal neighbor
            if(x<cols-1){
              addConstraint(idx,grid[y][x+1], spacing*(stretchOn?stretchFactor:BASE_STRETCH));
            }
            // Vertical neighbor
            if(y<rows-1){
              addConstraint(idx,grid[y+1][x], spacing*(stretchOn?stretchFactor:BASE_STRETCH));
            }
          }
        }
        // Bending constraints (two apart)
        for(let y=0;y<rows;y++){
          for(let x=0;x<cols-2;x++){
            let idx1=grid[y][x], idx2=grid[y][x+2];
            addConstraint(idx1,idx2, spacing*2*(bendingOn?bendingFactor:BASE_BENDING));
          }
        }
        for(let y=0;y<rows-2;y++){
          for(let x=0;x<cols;x++){
            let idx1=grid[y][x], idx2=grid[y+2][x];
            addConstraint(idx1,idx2, spacing*2*(bendingOn?bendingFactor:BASE_BENDING));
          }
        }
        // Shear constraints (diagonals)
        for(let y=0;y<rows-1;y++){
          for(let x=0;x<cols-1;x++){
            let idxA=grid[y][x], idxB=grid[y][x+1];
            let idxC=grid[y+1][x], idxD=grid[y+1][x+1];
            addConstraint(idxA,idxD, sqrt(2)*spacing*(shearOn?shearFactor:BASE_SHEAR));
            addConstraint(idxB,idxC, sqrt(2)*spacing*(shearOn?shearFactor:BASE_SHEAR));
          }
        }
        // Subdivide each cell
        for(let y=0;y<rows-1;y++){
          for(let x=0;x<cols-1;x++){
            let A=grid[y][x], B=grid[y][x+1];
            let C=grid[y+1][x], D=grid[y+1][x+1];
            let E=horizontal[y][x], F=horizontal[y+1][x];
            let G=vertical[y][x],   H=vertical[y][x+1];
            let I=centers[y][x];

            function cDist(i1,i2){
              let p1=clothPoints[i1], p2=clothPoints[i2];
              let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
              return sqrt(dx*dx+dy*dy+dz*dz);
            }

            function cAdd(i1,i2){ addConstraint(i1,i2,cDist(i1,i2)); }

            // 8 triangles => each triplet: cAdd(A,E), cAdd(E,I), cAdd(I,A), etc.
            cAdd(A,E); cAdd(E,I); cAdd(I,A);
            cAdd(A,G); cAdd(G,I); cAdd(I,A);
            cAdd(B,E); cAdd(E,I); cAdd(I,B);
            cAdd(B,H); cAdd(H,I); cAdd(I,B);
            cAdd(C,G); cAdd(G,I); cAdd(I,C);
            cAdd(C,F); cAdd(F,I); cAdd(I,C);
            cAdd(D,H); cAdd(H,I); cAdd(I,D);
            cAdd(D,F); cAdd(F,I); cAdd(I,D);
          }
        }
      }

      function addConstraint(i,j,len){
        let a=min(i,j), b=max(i,j);
        for(let c of clothConstraints){
          if(c.p1===a && c.p2===b) return;
        }
        clothConstraints.push({p1:a,p2:b,length:len});
      }

      function distBetween(i1,i2){
        let p1=clothPoints[i1], p2=clothPoints[i2];
        let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
        return sqrt(dx*dx+dy*dy+dz*dz);
      }

      function updateCloth(){
        let freq=0.01;
        for(let p of clothPoints){
          if(!p.pinned){
            let vx=(p.x-p.oldx)*(dampingOn?damping:BASE_DAMPING);
            let vy=(p.y-p.oldy)*(dampingOn?damping:BASE_DAMPING);
            let vz=(p.z-p.oldz)*(dampingOn?damping:BASE_DAMPING);
            p.oldx=p.x; p.oldy=p.y; p.oldz=p.z;

            let sinVal=sin(frameCount*freq);
            let effWindX= windXOn? (windBuffer*(windX)*sinVal) : BASE_WINDX;
            let effWindY= windYOn? (windBuffer*(windY)*sinVal) : BASE_WINDY;
            let effWindZ= windZOn? (windBuffer*(windZ)*sinVal) : BASE_WINDZ;

            let effGrav= (gravityOn? gravity : BASE_GRAVITY);
            let effWeight= (weightOn? weight : BASE_WEIGHT);

            p.x+= vx + effWindX;
            p.y+= vy + effGrav*effWeight + effWindY;
            p.z+= vz + effWindZ;
          }
        }
        let effIter= (iterationsOn? iterations : BASE_ITERATIONS);
        for(let i=0;i<effIter;i++){
          for(let c of clothConstraints){
            let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
            let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
            let distVal= sqrt(dx*dx + dy*dy + dz*dz);
            let diff= (distVal - c.length)/distVal;
            let offsetX= dx*0.5*diff, offsetY= dy*0.5*diff, offsetZ= dz*0.5*diff;
            if(!p1.pinned){
              p1.x+= offsetX; p1.y+= offsetY; p1.z+= offsetZ;
            }
            if(!p2.pinned){
              p2.x-= offsetX; p2.y-= offsetY; p2.z-= offsetZ;
            }
          }
        }
        doSelfCollision();

        if(simulationMode==="draped"){
          if(formMode==="sphere") doSphereCollision();
          else if(formMode==="cylinder") doCylinderCollision();
          doFloorCollision();
        }
      }

      function doSelfCollision(){
        let threshold= spacing*0.5;
        for(let i=0;i<clothPoints.length;i++){
          for(let j=i+1;j<clothPoints.length;j++){
            let p1=clothPoints[i], p2=clothPoints[j];
            let dx=p2.x-p1.x, dy=p2.y-p1.y, dz=p2.z-p1.z;
            let d= sqrt(dx*dx + dy*dy + dz*dz);
            if(d<threshold && d>0){
              let overlap= threshold-d;
              let angle= atan2(dy,dx);
              if(!p1.pinned && !p2.pinned){
                p1.x-= cos(angle)*overlap*0.5;
                p1.y-= sin(angle)*overlap*0.5;
                p2.x+= cos(angle)*overlap*0.5;
                p2.y+= sin(angle)*overlap*0.5;
              } else if(!p1.pinned && p2.pinned){
                p1.x-= cos(angle)*overlap;
                p1.y-= sin(angle)*overlap;
              } else if(p1.pinned && !p2.pinned){
                p2.x+= cos(angle)*overlap;
                p2.y+= sin(angle)*overlap;
              }
            }
          }
        }
      }

      function doSphereCollision(){
        const collisionFriction=0.5;
        for(let p of clothPoints){
          if(!p.pinned){
            let dx=p.x-sphereCenter.x, dy=p.y-sphereCenter.y, dz=p.z-sphereCenter.z;
            let distVal= sqrt(dx*dx + dy*dy + dz*dz);
            if(distVal< sphereRadius){
              let overlap= sphereRadius-distVal;
              let nx= dx/distVal, ny= dy/distVal, nz= dz/distVal;
              p.x+= nx*overlap; p.y+= ny*overlap; p.z+= nz*overlap;
              p.oldx= p.x - collisionFriction*(p.x-p.oldx);
              p.oldy= p.y - collisionFriction*(p.y-p.oldy);
              p.oldz= p.z - collisionFriction*(p.z-p.oldz);
            }
          }
        }
      }

      function doCylinderCollision(){
        const collisionFriction=0.5;
        for(let p of clothPoints){
          if(!p.pinned){
            // Cylinder from y=150 to y=450
            if(p.y>=cylinderBottomY && p.y<=cylinderTopY){
              let r= sqrt(p.x*p.x + p.z*p.z);
              if(r<cylRadius){
                let overlap= cylRadius-r;
                let nx= p.x/r, nz= p.z/r;
                p.x+= nx*overlap; p.z+= nz*overlap;
                p.oldx= p.x - collisionFriction*(p.x-p.oldx);
                p.oldz= p.z - collisionFriction*(p.z-p.oldz);
              }
            }
          }
        }
      }

      function doFloorCollision(){
        // If cloth point y> floorY => clamp
        const collisionFriction=0.5;
        for(let p of clothPoints){
          if(!p.pinned && p.y>floorY){
            p.y= floorY;
            p.oldy= p.y - collisionFriction*(p.y-p.oldy);
          }
        }
      }

      // 3D Dragging
      function mousePressed(){
        if(interactionMode==="drag"){
          let closest=null, closestDist=10;
          for(let i=0;i<clothPoints.length;i++){
            let p=clothPoints[i];
            let sx=modelX(p.x,p.y,p.z), sy=modelY(p.x,p.y,p.z);
            let d=dist(mouseX,mouseY,sx,sy);
            if(d<closestDist){closestDist=d;closest=i;}
          }
          if(closest!==null){
            dragPointIndex=closest;
            dragPlaneZ=clothPoints[closest].z;
          }
        }
      }

      function mouseDragged(){
        if(interactionMode==="drag" && dragPointIndex!==null){
          let newPos= unproject(mouseX,mouseY,dragPlaneZ);
          let p=clothPoints[dragPointIndex];
          p.x= newPos.x; p.y= newPos.y;
          p.oldx= newPos.x; p.oldy= newPos.y;
        }
      }

      function mouseReleased(){
        dragPointIndex=null;
      }

      function unproject(mx,my,fixedZ){
        let d=(height/2)/tan(PI*30/180);
        let nx=mx-width/2, ny=my-height/2;
        let factor=(d+fixedZ)/d;
        return createVector(nx*factor, ny*factor, fixedZ);
      }

      function draw(){
        background(30);
        if(doResetOrientation){
          camera(0,0,(height/2)/tan(PI*30/180), 0,0,0, 0,1,0);
          doResetOrientation=false;
        }
        if(interactionMode==="rotate"){
          orbitControl();
        }
        if(simulationRunning){
          updateCloth();
        }

        if(simulationMode==="draped"){
          noStroke();
          fill("#222");
          if(formMode==="sphere"){
            push();
            translate(sphereCenter.x, sphereCenter.y, sphereCenter.z);
            sphere(sphereRadius);
            pop();
          } else {
            // Cylinder bottom=150, top=450 => midpoint=300
            push();
            let midY=(cylinderBottomY+cylinderTopY)*0.5; // 300
            translate(0,midY,0);
            cylinder(cylRadius,cylHeight);
            pop();
          }
          // Invisible floor at y=150
          push();
          translate(0,floorY,0);
          noFill();
          plane(1000,1000);
          pop();
        }

        if(shadingOn){
          let minY=Infinity, maxY=-Infinity;
          for(let y=0;y<rows;y++){
            for(let x=0;x<cols;x++){
              let pt=clothPoints[grid[y][x]];
              if(pt.y<minY) minY=pt.y;
              if(pt.y>maxY) maxY=pt.y;
            }
          }
          noStroke();
          for(let y=0;y<rows-1;y++){
            for(let x=0;x<cols-1;x++){
              let A=clothPoints[grid[y][x]];
              let B=clothPoints[grid[y][x+1]];
              let C=clothPoints[grid[y+1][x+1]];
              let D=clothPoints[grid[y+1][x]];
              let avgY=(A.y+B.y+C.y+D.y)*0.25;
              let bright=map(avgY,minY,maxY,220,80);
              fill(bright);
              beginShape();
              vertex(A.x,A.y,A.z);
              vertex(B.x,B.y,B.z);
              vertex(C.x,C.y,C.z);
              vertex(D.x,D.y,D.z);
              endShape(CLOSE);
            }
          }
        }

        stroke(255); strokeWeight(2);
        for(let c of clothConstraints){
          let p1=clothPoints[c.p1], p2=clothPoints[c.p2];
          line(p1.x,p1.y,p1.z,p2.x,p2.y,p2.z);
        }

        noStroke(); fill("#FF0000");
        for(let p of clothPoints){
          push();
          translate(p.x,p.y,p.z);
          sphere(2);
          pop();
        }
      }

      function windowResized(){
        resizeCanvas(windowWidth-280,windowHeight);
      }
    </script>
  </body>
</html>

